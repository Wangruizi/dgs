<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>联通“通通”的奇妙之旅</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior-y: contain; /* Prevent pull-to-refresh issues on mobile */
        }
        /* Base style for all sections: hidden by default */
        .section {
            min-height: 100vh;
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
            position: relative; 
        }
        /* Style for the currently active section: make it visible and a flex container */
        .active-section {
            display: flex;
        }

        /* Global back button style */
        .global-back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.3s, transform 0.2s, opacity 0.3s, filter 0.3s;
        }
        .global-back-button img {
            width: 40px; 
            height: 40px; 
        }
        .global-back-button:hover:not(.disabled) {
            background-color: rgba(255, 255, 255, 0.9);
            transform: scale(1.1);
        }
        .global-back-button.disabled {
            opacity: 0.5;
            filter: blur(1px);
            pointer-events: none;
            cursor: default;
        }

        /* Styles for Tongtong hotspot interaction */
        .tongtong-hotspot-container {
            position: relative;
            width: 300px; 
            height: 300px; 
            margin-bottom: 20px;
            background-color: #f0f0f0; 
        }
        .tongtong-hotspot-container img {
            width: 100%;
            height: 100%;
            object-fit: contain; 
            border-radius: 12px;
        }
        .hotspot {
            position: absolute;
            width: 35px;
            height: 35px;
            background-color: rgba(255, 102, 0, 0.9); 
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.875rem; 
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            transition: transform 0.2s ease-in-out, background-color 0.2s, opacity 0.3s, filter 0.3s; /* Added opacity and filter */
        }
        .hotspot:hover {
            transform: scale(1.15);
            background-color: rgba(230, 80, 0, 1); 
        }
        .hotspot-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 1000; 
            width: 85%;
            max-width: 380px;
            display: none; 
        }
        /* Styles for the clicker game area */
        .game-area {
            width: 100%;
            max-width: 400px; 
            height: 300px; 
            background-color: #fff0e6; 
            border-radius: 12px;
            position: relative;
            overflow: visible; 
            margin-top: 15px;
            margin-bottom: 15px;
            border: 3px solid #FF6600; 
        }
        .game-tongtong {
            position: absolute;
            width: 60px;
            height: 60px;
            background-image: url('xia.png'); 
            background-color: #FFFACD; 
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 50%;
            cursor: pointer;
            transition: opacity 0.3s, transform 0.2s;
            box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
        }
        .game-tongtong:hover {
            transform: scale(1.1);
        }
        .game-info {
            font-size: 1.125rem; 
            color: #555;
            margin-bottom: 10px;
        }
        .game-info span {
            font-weight: bold;
            color: #FF6600; 
        }

        /* Styles for product grid */
        .product-grid-container {
            width: 100%; 
            overflow: hidden; 
        }
        .product-grid {
            display: flex;
            overflow-x: auto; 
            overflow-y: hidden; 
            scroll-snap-type: x mandatory; 
            -webkit-overflow-scrolling: touch; 
            padding: 20px 10px; 
            width: 100%; 
            box-sizing: border-box;
        }
        .product-grid::-webkit-scrollbar { height: 8px; }
        .product-grid::-webkit-scrollbar-thumb { background: #FF6600; border-radius: 4px; }
        .product-grid::-webkit-scrollbar-track { background: #ffe8cc; border-radius: 4px; }

        .product-item {
            flex: 0 0 300px; 
            max-width: 320px; 
            height: auto;
            min-height: 380px; 
            background-color: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-right: 15px; 
            scroll-snap-align: center; 
            scroll-snap-stop: always; 
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .product-item:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .product-item:last-child { margin-right: 0; } 
        .product-item img {
            width: 100%;
            height: 200px; 
            object-fit: cover; 
            border-radius: 12px;
            margin-bottom: 16px;
            background-color: #e0e0e0; 
        }
        .product-item h3 { font-size: 1.25rem; font-weight: 600; color: #333; line-height: 1.4; margin-bottom: 8px; }
        .product-item-short-desc {
            font-size: 0.9rem; 
            color: #555;
            line-height: 1.5;
            margin-bottom: 10px;
            flex-grow: 1; 
            text-align: center; 
        }
        .product-item p.static-description { 
            font-size: 0.9rem;
            color: #555;
            line-height: 1.5;
            flex-grow: 1;
            margin-bottom: 10px;
            text-align: left; 
            display: none; 
        }
        .product-item-price { font-size: 1rem; font-weight: bold; color: #FF6600; margin-top: auto; }

        /* Button styles */
        .button-primary, .button-secondary { /* Combined for shared properties */
            padding: 10px 20px; 
            border-radius: 9999px; 
            font-weight: 600; 
            text-decoration: none; 
            display: inline-block; 
            margin-top: 10px;
            transition: background-color 0.3s, transform 0.1s ease-in-out, opacity 0.3s, filter 0.3s; /* Added opacity and filter */
            border: none; 
            cursor: pointer;
        }
        .button-primary {
            background-color: #FF6600; color: white; padding: 12px 24px; margin-top: 20px;
        }
        .button-primary:hover:not([style*="pointer-events: none"]) { background-color: #E65C00; } /* Check for disabled state */
        
        .button-secondary {
            background-color: #FFA500; color: white;  margin-right: 10px;
        }
        .button-secondary:hover:not([style*="pointer-events: none"]) { background-color: #FF8C00; }


        /* General Modal styles */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center;
            z-index: 1000; padding: 15px; box-sizing: border-box;
        }
        .modal-content {
            background-color: white; padding: 25px; border-radius: 16px; text-align: center;
            width: 90%; max-width: 450px; box-shadow: 0 8px 24px rgba(0,0,0,0.25);
            position: relative; max-height: 90vh; overflow-y: auto; 
        }
        .modal-content h3 { font-size: 1.5rem; font-weight: 700; color: #FF6600; margin-bottom: 15px; }
        .modal-content p { margin-bottom: 20px; font-size: 1rem; color: #333; line-height: 1.6; }
        
        .modal-close-button { 
            position: absolute; top: 10px; right: 10px; background: #eee; color: #333; border: none;
            border-radius: 50%; width: 30px; height: 30px; font-size: 18px; line-height: 30px;
            text-align: center; cursor: pointer; font-weight: bold;
        }
        .modal-close-button:hover { background: #ddd; }

        /* Product Detail Modal specific styles */
        #productDetailModal { backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        #productDetailModal .modal-content { max-width: 500px; }
        #productDetailModal .modal-close-button { 
            position: sticky; /* MODIFIED: Changed from absolute to sticky */
            top: 15px; 
            right: 15px; 
            /* The button needs to be a direct child or appropriately positioned for sticky to work relative to scroll container */
            /* If .modal-content is the scroll container, this should stick to its top-right */
            float: right; /* ADDED: to help ensure it stays on the right */
            margin-bottom: -35px; /* ADDED: to pull it up if content flows around it, adjust as needed */
            background: rgba(230, 230, 230, 0.9);
            color: #333;
            border: none;
            border-radius: 50%;
            width: 35px; 
            height: 35px;
            font-size: 20px;
            line-height: 35px; 
            text-align: center;
            cursor: pointer;
            font-weight: bold;
            z-index: 20; /* Increased z-index to ensure it's above other content within modal-content */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #productDetailModal .modal-close-button:hover {
            background: rgba(220, 220, 220, 1);
        }

        #productDetailImage {
            width: 100%; max-height: 300px; object-fit: contain; border-radius: 12px;
            margin-bottom: 20px; background-color: #f9f9f9; 
            margin-top: 10px; /* ADDED: To prevent overlap with sticky button if it's the very first item */
        }
        #productDetailName { font-size: 1.75rem; font-weight: 700; color: #FF6600; margin-bottom: 10px; clear: both; /* ADDED: In case of float issues from button */ }
        #productDetailDescription { font-size: 1rem; color: #555; margin-bottom: 15px; min-height: 50px; text-align: left; clear: both; }
        #productDetailPrice { font-size: 1.5rem; font-weight: bold; color: #E65C00; margin-bottom: 25px; clear: both; }
        #ai-description-loader {
            font-size: 0.9rem;
            color: #666;
            margin: 10px 0;
        }

        /* Maze game styles */
        #mazeCanvas {
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: block; 
            margin-left: auto;
            margin-right: auto;
        }
        .maze-canvas-wrapper {
            position: relative; 
            width: 300px; 
            height: 300px; 
            margin-left: auto;
            margin-right: auto;
            overflow: hidden; 
            border-radius: 12px;
            background-image: url('mgbg2.png'); 
            background-size: cover;
            background-position: center;
            border: 2px solid #A855F7; 
        }
        .maze-arrow-button {
            background-color: #A855F7; color: white; padding: 0.75rem; border-radius: 9999px;
            font-weight: 600; text-decoration: none; display: inline-flex; align-items: center; justify-content: center;
            transition: transform 0.1s ease-in-out, background-color 0.3s ease-in-out;
            border: none; cursor: pointer; width: 60px; height: 60px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .maze-arrow-button:hover { background-color: #9333EA;  }
        .maze-arrow-button.pressed { transform: scale(0.9); background-color: #7E22CE; }

        .game-timer-info { font-size: 1.125rem; color: #4B0082; margin-bottom: 10px; } 
        .game-timer-info span { font-weight: bold; color: #6D28D9; }

        /* Music toggle button style */
        .music-toggle-button {
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: background-color 0.3s, transform 0.1s;
        }
        .music-toggle-button:hover {
            background-color: rgba(255, 255, 255, 0.9);
            transform: scale(1.1);
        }
        .music-toggle-button img { width: 20px; height: 20px; display: block; }

        #match-game-music-toggle {
            margin-left: 8px; 
        }

        /* QR Code Modal specific styles */
        #qrCodeModal .modal-content {
            max-width: 380px;
        }
        #qrCodeImage {
            width: 100%;
            max-width: 280px; 
            height: auto;
            object-fit: contain;
            border-radius: 8px;
            margin-top: 10px;
            margin-bottom: 20px;
        }

        /* Styles for Match-3 Game (消消乐) */
        #section-match-game {
            color: #333;
            font-family: 'Inter', 'Segoe UI', 'Microsoft YaHei', Arial, sans-serif;
        }
        #section-match-game h1 {
            margin-top: 20px; 
            color: #166534; 
            font-size: 2em; 
        }
        #section-match-game .desc {
            color: #374151; 
            margin-bottom: 15px;
            text-align: center;
            max-width: 500px; 
            font-size: 0.9em; 
        }
        #section-match-game .stats-container {
            display: flex;
            justify-content: center; 
            align-items: center;
            width: 100%;
            max-width: 480px; 
            margin-left: auto;
            margin-right: auto;
            margin-bottom: 15px;
            font-size: 1em; 
            gap: 10px; 
        }
        #section-match-game #score,
        #section-match-game #timer,
        #section-match-game #hint-count-display {
            background-color: #ffffff;
            padding: 8px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.07);
            font-weight: 500;
        }
        #section-match-game #timer { color: #c0392b; } 
        #section-match-game #score { color: #15803d; } 
        #section-match-game #hint-count-display { color: #2563eb; } 

        #section-match-game .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            justify-content: center; 
            width: 100%;
            max-width: 480px; 
            margin-left: auto;
            margin-right: auto;
        }
        
        #section-match-game #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr); 
            grid-template-rows: repeat(8, 1fr);    
            gap: 6px; 
            background-color: #bbf7d0; 
            border-radius: 12px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.1);
            padding: 6px; 
            width: 95%; 
            aspect-ratio: 1 / 1; 
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
            max-width: 500px; 
        }
        
        #section-match-game .cell {
            background: #a7f3d0; 
            border: none; 
            border-radius: 12px; 
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: box-shadow 0.2s, transform 0.2s;
            overflow: hidden; 
            margin: 0; 
            padding: 0; 
            position: relative; 
        }
        
        #section-match-game .cell.selected {
            box-shadow: 0 0 0 3px #f59e0b; 
            transform: scale(1.05);
            border-radius: 12px; 
            z-index: 2; 
        }
        
        #section-match-game .cell img {
            width: 96%; 
            height: 96%;
            object-fit: cover; 
            object-position: center;
            border: none; 
            border-radius: 10px; 
            pointer-events: none; 
            user-select: none; 
            display: block; 
        }
        /* Match-3 Animations */
        #section-match-game .cell.disappear { animation: xxl-disappear 0.4s forwards; }
        @keyframes xxl-disappear {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.2); }
        }
        #section-match-game .cell.fall { animation: xxl-fall 0.4s cubic-bezier(.4,1.4,.6,1) forwards; }
        @keyframes xxl-fall {
            0% { transform: translateY(-100%); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        /* Match-3 Control Buttons */
        #section-match-game .controls .game-button,
        #section-match-game #match-game-to-products-btn {
            color: white; padding: 10px 20px; border-radius: 9999px; 
            font-weight: 600; text-decoration: none; display: inline-block;
            transition: background-color 0.3s, transform 0.1s ease-in-out;
            border: none; cursor: pointer; font-size: 1em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        #section-match-game .controls .game-button:hover:not(:disabled),
        #section-match-game #match-game-to-products-btn:hover:not(:disabled) {
            transform: translateY(-1px); 
        }
        #section-match-game .controls .game-button:active,
        #section-match-game #match-game-to-products-btn:active {
             transform: translateY(1px); 
        }
        #section-match-game .controls .game-button:disabled,
        #section-match-game #match-game-to-products-btn:disabled {
            background-color: #9ca3af; color: #e5e7eb; 
            cursor: not-allowed; transform: none; box-shadow: none;
        }
        #section-match-game #action-btn { background-color: #22c55e; } 
        #section-match-game #action-btn:hover:not(:disabled) { background-color: #16a34a; } 
        #section-match-game #hint-btn { background-color: #3b82f6; } 
        #section-match-game #hint-btn:hover:not(:disabled) { background-color: #2563eb; } 
        #section-match-game #match-game-to-products-btn {
            background-color: #f97316; 
        }
        #section-match-game #match-game-to-products-btn:hover:not(:disabled) { background-color: #ea580c; }        
        /* Hint Highlight Styles */
        #section-match-game .hint {
            box-shadow: 0 0 0 3px #00e0ff, 0 0 12px 4px #ffffff, 0 0 0 8px #ffffff00 inset; 
            outline: 2px solid #00e0ff; outline-offset: -2px;
            border-radius: 12px; 
            position: relative; z-index: 4;  animation: xxl-hint-pulse 0.7s infinite alternate;
        }
        @keyframes xxl-hint-pulse {
            0% { box-shadow: 0 0 0 3px #00e0ff, 0 0 12px 4px #ffffff, 0 0 0 8px #ffffff00 inset; }
            100% { box-shadow: 0 0 0 7px #00e0ff, 0 0 18px 8px #ffffff, 0 0 0 12px #ffffff00 inset; }
        }
        #section-match-game .hint-animate { animation: xxl-hint-swap 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55) 2 alternate; }
        @keyframes xxl-hint-swap { 
            0% { transform: none; }
            50% { transform: scale(1.15) translate(var(--xxl-hint-x,0), var(--xxl-hint-y,0)); }
            100% { transform: none; }
        }
        /* Cell Swap Animations */
        #section-match-game .cell.swap { transition: transform 0.25s ease-in-out; z-index: 10; }
        #section-match-game .cell.swap-back-half { transition: transform 0.13s ease-out; z-index: 10; }
        #section-match-game .cell.swap-back { transition: transform 0.13s ease-in; z-index: 10; }

        /* Match-3 Message Box */
        #section-match-game .message-box-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
            opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
        }
        #section-match-game .message-box-overlay.visible { opacity: 1; visibility: visible; }
        #section-match-game .message-box {
            background-color: white; padding: 25px; border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); text-align: center; max-width: 80%;
        }
        #section-match-game .message-box p { margin: 0 0 15px 0; font-size: 1.1em; color: #333; }
        #section-match-game .message-box button#message-box-ok {
            background-color: #16a34a; color: white; border: none; 
            border-radius: 8px; padding: 10px 20px; font-size: 1em; cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); font-weight: 500;
        }
        #section-match-game .message-box button#message-box-ok:hover {
            background-color: #15803d; transform: translateY(-1px); 
        }

        /* Styles for the new Chat Modal */
        #tongtong-chat-modal-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 450px; 
            background-color: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            z-index: 1002; 
            display: none; 
            flex-direction: column; 
        }
        #tongtong-chat-modal-container h3 { 
            font-size: 1.25rem; 
            font-weight: 600; 
            color: #0EA5E9; 
            margin-bottom: 0.75rem; 
            text-align: center;
        }
        #chat-history-modal { 
            height: 250px; 
            border: 1px solid #e5e7eb; 
            border-radius: 0.375rem; 
            padding: 0.75rem; 
            overflow-y: auto;
            margin-bottom: 0.75rem; 
            background-color: #f9fafb; 
        }
        .chat-message-modal { 
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
            max-width: 90%; 
            word-wrap: break-word;
            line-height: 1.5;
        }
        .user-message-modal {
            background-color: #F0F9FF; 
            color: #075985;    
            margin-left: auto;
            text-align: right;
        }
        .ai-message-modal {
            background-color: #F5F3FF; 
            color: #5B21B6;    
            margin-right: auto;
            text-align: left;
            display: flex; 
            align-items: flex-start; 
            gap: 8px; 
        }
        .chat-avatar {
            width: 28px; 
            height: 28px;
            border-radius: 50%;
            flex-shrink: 0; 
            margin-top: 2px; 
        }
        .message-text-modal { 
            flex-grow: 1;
        }

        #chat-input-modal-wrapper { 
            display: flex;
            gap: 0.5rem; 
            margin-top: 0.75rem; 
        }
        #chat-input-modal { 
            flex-grow: 1;
            border: 1px solid #d1d5db; 
            border-radius: 0.375rem; 
            padding: 0.5rem 0.75rem; 
            min-width: 0; 
        }
        #chat-input-modal:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            border-color: #0EA5E9; 
            box-shadow: 0 0 0 2px #7DD3FC; 
        }
        #close-chat-modal-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.8rem;
            color: #9ca3af; 
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
        }
        #close-chat-modal-btn:hover {
            color: #4b5563; 
        }
         #chat-loading-modal { 
            display:none;
            font-size: 0.875rem; 
            color: #6b7280; 
            margin-top: 0.5rem; 
            text-align: center;
        }


        /* Responsive adjustments */
        @media (max-width: 600px) {
            /* Match-3 game responsive styles */
            #section-match-game h1 { font-size: 1.5em; }
            #section-match-game .desc { font-size: 0.8em; }
            #section-match-game .stats-container {
                font-size: 0.85em; flex-direction: column; 
                gap: 8px; align-items: center; 
            }
            #section-match-game .controls .game-button,
            #section-match-game #match-game-to-products-btn,
            #section-match-game .message-box button#message-box-ok { padding: 8px 15px; font-size: 0.9em; }
            #section-match-game .controls { flex-wrap: wrap; justify-content: center;} 

            /* Maze game responsive styles */
            #section-maze .flex-col-reverse-sm { 
                display: flex;
                flex-direction: column-reverse;
            }
            
            #maze-game-controls { 
                order: 1; 
                margin-bottom: 0.75rem; 
            }
            #maze-controls-mobile { 
                order: 2; 
            }
        }
    </style>
</head>
<body class="bg-orange-50">

    <div id="global-back-button" class="global-back-button" onclick="navigateBack()" style="display:none;">
        <img src="back.png" alt="返回" onerror="this.style.display='none'; this.parentElement.innerHTML = '<span style=\'font-size:20px;\'>←</span>'">
    </div>

    <section id="section-welcome" class="section active-section bg-gradient-to-br from-orange-400 to-red-500 text-white">
        <div class="flex flex-col items-center">
            <img src="liantongwenchuang.png" alt="通通吉祥物" class="w-48 h-48 md:w-64 md:h-64 rounded-full shadow-2xl mb-8 animate-bounce" onerror="this.alt='联通文创Logo'; this.style.backgroundColor='#ccc';">
            <h1 class="text-4xl md:text-5xl font-bold mb-4">遇见通通</h1>
            <p class="text-lg md:text-xl mb-8">开启你的奇妙文创之旅！</p>
            <button onclick="navigateTo('section-explore')" class="bg-white text-orange-600 border-2 border-orange-600 hover:bg-orange-50 text-lg font-semibold py-3 px-8 rounded-full shadow-md hover:shadow-lg transition-transform transform hover:scale-105">开始探索</button>
        </div>
    </section>

    <section id="section-explore" class="section bg-orange-100">
        <h2 class="text-3xl font-bold text-orange-600 mb-6">认识通通</h2>
        <p class="mb-4 text-gray-700">点击通通身上的亮点，发现更多惊喜！</p>
        <div class="tongtong-hotspot-container bg-white p-2 rounded-2xl shadow-lg">
            <img src="zm.png"
                 alt="通通互动形象"
                 id="tongtong-interactive-image"
                 onerror="this.alt='通通图片'; this.style.backgroundColor='#ddd';"
                 >
            <div class="hotspot explore-interactive" style="top: 0%; left: 15%;" onclick="showHotspotInfo('通通的触角', '这对可爱的触角，象征着联通源源不断的信息与能量')">1</div>
            <div class="hotspot explore-interactive" style="top: 25%; left: 80%;" onclick="showHotspotInfo('通通的笑脸', '通通时刻保持微笑，为您提供最贴心的服务。')">2</div>
            <div class="hotspot explore-interactive" style="top: 75%; left: 75%;" onclick="showHotspotInfo('拟人化外观', '色调为联通中国红，以机器人为原型，融合现代科技与人性化设计，增强了通通的亲和力和科技感')">3</div>
        </div>
        <div id="hotspot-popup" class="hotspot-popup">
            <h3 id="hotspot-title" class="text-xl font-semibold text-orange-600 mb-2"></h3>
            <p id="hotspot-text" class="text-gray-700 mb-4"></p>
            <div id="ai-hotspot-loading" style="display:none;" class="text-sm text-gray-500 my-2">✨ 通通正在解读奥秘...</div>
            <div id="ai-hotspot-content" class="mt-2"></div>
            <button id="enhance-hotspot-btn" class="button-secondary text-sm mt-3 w-full">✨ AI解读通通更多奥秘</button>
            <button onclick="closeHotspotInfo()" class="button-primary text-sm mt-2">关闭</button>
        </div>

        <div class="flex flex-col sm:flex-row flex-wrap justify-center gap-4 mt-8">
            <button onclick="navigateTo('section-match-game')" class="button-primary bg-green-500 hover:bg-green-700 explore-interactive">文创消消乐</button>
            <button onclick="navigateTo('section-game')" class="button-primary explore-interactive">通通快手点击</button>
            <button onclick="navigateTo('section-maze')" class="button-primary bg-purple-600 hover:bg-purple-700 explore-interactive">挑战通通迷宫</button>
        </div>

        <button id="tongtong-chat-toggle-button" class="button-primary bg-sky-500 hover:bg-sky-600 py-2 px-4 text-base !mt-6 explore-interactive">💬 和通通聊聊天</button>
    </section>

    <div id="tongtong-chat-modal-container">
        <button id="close-chat-modal-btn">&times;</button>
        <h3>和通通聊聊天</h3>
        <div id="chat-history-modal">
            <div class="ai-message-modal chat-message-modal">
                <img src="xia.png" alt="通通头像" class="chat-avatar" onerror="this.style.display='none';">
                <span class="message-text-modal">你好！我是通通，有什么可以帮你的吗？（通通的回答可能有误，请注意甄别）</span>
            </div>
        </div>
        <div id="chat-input-modal-wrapper">
            <input type="text" id="chat-input-modal" placeholder="问通通一些问题吧...">
            <button id="send-chat-modal-btn" class="button-primary bg-sky-500 hover:bg-sky-600 py-2 px-3 sm:px-4 text-sm !mt-0 flex-shrink-0">发送</button>
        </div>
        <div id="chat-loading-modal">通通正在思考...</div>
    </div>


    <section id="section-game" class="section bg-red-100">
        <h2 class="text-3xl font-bold text-red-600 mb-4">通通快手点击</h2>
        
        <div class="w-full max-w-[400px] mx-auto relative mb-2">
            <div id="click-game-music-toggle" class="music-toggle-button absolute top-[50px] right-0 z-10">
                <img src="music_on.png" alt="Music On" onerror="this.parentElement.innerHTML = '<span style=\'font-size:12px;\'>🎵On</span>';">
            </div>
        </div>

        <p class="game-info">倒计时: <span id="game-timer">10</span> 秒</p>
        <p class="game-info">得分: <span id="game-score">0</span></p>
        <div id="game-area" class="game-area" style="background-image: url('ksbg.png'); background-size: cover; background-position: center;">
            </div>
        <div id="game-controls" class="mt-4">
            <button id="start-game-btn" onclick="startGame()" class="button-primary text-lg">开始游戏</button>
            <button id="to-products-btn" onclick="navigateTo('section-products')" class="button-secondary text-lg" style="display:none;">查看文创产品</button>
        </div>
    </section>

    <section id="section-products" class="section bg-orange-50">
        <h2 class="text-3xl font-bold text-orange-600 mb-6">通通的文创宝库</h2>
        <div class="product-grid-container">
            <div class="product-grid">
                <div class="product-item" onclick="showProductDetail(this)" data-price="¥89" data-name="通通保温杯" 
                     data-description="这是一款时尚的白色通通主题保温杯。杯体中央印有可爱的橙色通通吉祥物形象，背景是现代都市的楼宇剪影图案，富有设计感。杯盖为弹扣式，方便单手开启。整体材质看起来光滑有质感，适合日常携带，为您随时锁住饮品温度。" 
                     data-img-src="文创产品/0918_01_保温杯.(1).jpg">
                    <img src="文创产品/0918_01_保温杯.(1).jpg" alt="通通保温杯" onerror="this.alt='保温杯图片'; this.src='https://placehold.co/300x200/E0E0E0/333333?text=保温杯';">
                    <h3>通通保温杯</h3>
                    <p class="product-item-short-desc">时尚联通定制保温杯，温暖常伴，让爱联通。</p>
                    <p class="static-description">这是一款时尚的白色通通主题保温杯。杯体中央印有可爱的橙色通通吉祥物形象，背景是现代都市的楼宇剪影图案，富有设计感。杯盖为弹扣式，方便单手开启。整体材质看起来光滑有质感，适合日常携带，为您随时锁住饮品温度。</p>
                    <p class="product-item-price">¥89</p>
                </div>
                <div class="product-item" onclick="showProductDetail(this)" data-price="¥49" data-name="通通充电线" 
                     data-description="这是一款充满活力的橙色通通主题三合一充电线。线材采用螺旋伸缩设计，便于收纳和调节长度。充电线一端接口处设计为可爱的通通公仔头像造型，大眼睛，头顶有白色小触角，非常萌趣。另一端是USB-A接口，适用于多种充电场景。"
                     data-img-src="文创产品/0918_01_充电线(1).jpg">
                    <img src="文创产品/0918_01_充电线(1).jpg" alt="通通充电线" onerror="this.alt='充电线图片'; this.src='https://placehold.co/300x200/E0E0E0/333333?text=充电线';">
                    <h3>通通充电线</h3>
                    <p class="product-item-short-desc">便捷三合一充电线，兼容多种设备，出行无忧。</p>
                    <p class="static-description">这是一款充满活力的橙色通通主题三合一充电线。线材采用螺旋伸缩设计，便于收纳和调节长度。充电线一端接口处设计为可爱的通通公仔头像造型，大眼睛，头顶有白色小触角，非常萌趣。另一端是USB-A接口，适用于多种充电场景。</p>
                    <p class="product-item-price">¥49</p>
                </div>
                <div class="product-item" onclick="showProductDetail(this)" data-price="¥29" data-name="通通地球钥匙扣" 
                     data-description="这款通通地球探索主题钥匙扣，主体为圆形金属徽章设计。徽章上层是深蓝色夜空背景下的地球图案，上面站立着手持笔记本电脑的通通公仔，周围点缀着闪亮的仿水钻。钥匙扣配有金色龙虾扣，方便挂取。整体设计精致，富有科技感和探索精神。"
                     data-img-src="文创产品/0918_01_地球款钥匙扣(1).jpg">
                    <img src="文创产品/0918_01_地球款钥匙扣(1).jpg" alt="通通地球钥匙扣" onerror="this.alt='地球钥匙扣图片'; this.src='https://placehold.co/300x200/E0E0E0/333333?text=地球钥匙扣';">
                    <h3>通通地球钥匙扣</h3>
                    <p class="product-item-short-desc">精致地球造型钥匙扣，联通世界，点缀生活。</p>
                    <p class="static-description">这款通通地球探索主题钥匙扣，主体为圆形金属徽章设计。徽章上层是深蓝色夜空背景下的地球图案，上面站立着手持笔记本电脑的通通公仔，周围点缀着闪亮的仿水钻。钥匙扣配有金色龙虾扣，方便挂取。整体设计精致，富有科技感和探索精神。</p>
                    <p class="product-item-price">¥29</p>
                </div>
                <div class="product-item" onclick="showProductDetail(this)" data-price="¥129" data-name="通通毛绒玩具" 
                     data-description="这是一款非常可爱的通通吉祥物毛绒公仔。公仔通体为标志性的联通橙色，头部戴着带有白色触角的头盔，露出圆圆的大眼睛和微笑的嘴巴。公仔为站立姿势，一只手举起向您招手，另一只手自然下垂。材质看起来柔软舒适，适合拥抱和玩耍。"
                     data-img-src="文创产品/0918_01_吉祥物毛绒玩具(1).jpg">
                    <img src="文创产品/0918_01_吉祥物毛绒玩具(1).jpg" alt="通通毛绒玩具" onerror="this.alt='毛绒玩具图片'; this.src='https://placehold.co/300x200/E0E0E0/333333?text=毛绒玩具';">
                    <h3>通通毛绒玩具</h3>
                    <p class="product-item-short-desc">超萌通通吉祥物公仔，柔软亲肤，送礼佳选。</p>
                    <p class="static-description">这是一款非常可爱的通通吉祥物毛绒公仔。公仔通体为标志性的联通橙色，头部戴着带有白色触角的头盔，露出圆圆的大眼睛和微笑的嘴巴。公仔为站立姿势，一只手举起向您招手，另一只手自然下垂。材质看起来柔软舒适，适合拥抱和玩耍。</p>
                    <p class="product-item-price">¥129</p>
                </div>
                <div class="product-item" onclick="showProductDetail(this)" data-price="¥199" data-name="金色通通手办" 
                     data-description="这款是限量版的金色通通手办摆件。通通公仔全身呈现闪亮的金色金属光泽，造型为经典的招手姿势，表情可爱。手办站立在一个圆柱形的金色底座上，底座上刻有'通通'字样。整体小巧精致，具有收藏价值和高级感。"
                     data-img-src="文创产品/0918_01_金色通通手办(1).jpg">
                    <img src="文创产品/0918_01_金色通通手办(1).jpg" alt="金色通通手办" onerror="this.alt='金色手办图片'; this.src='https://placehold.co/300x200/E0E0E0/333333?text=金色手办';">
                    <h3>金色通通手办</h3>
                    <p class="product-item-short-desc">限量版金色通通手办，精致收藏，彰显品味。</p>
                    <p class="static-description">这款是限量版的金色通通手办摆件。通通公仔全身呈现闪亮的金色金属光泽，造型为经典的招手姿势，表情可爱。手办站立在一个圆柱形的金色底座上，底座上刻有'通通'字样。整体小巧精致，具有收藏价值和高级感。</p>
                    <p class="product-item-price">¥199</p>
                </div>
                 <div class="product-item" onclick="showProductDetail(this)" data-price="¥25" data-name="通通手机挂绳" 
                      data-description="这是一款实用又时尚的通通主题手机挂绳。挂绳主体为红白相间的编织绳，上面印有连续的通通头像图案。连接手机的部分有一个可爱的通通公仔头像作为装饰和固定扣，造型萌趣。可以有效防止手机滑落，解放双手。"
                      data-img-src="文创产品/0918_01_手机挂绳(1).jpg">
                    <img src="文创产品/0918_01_手机挂绳(1).jpg" alt="通通手机挂绳" onerror="this.alt='手机挂绳图片'; this.src='https://placehold.co/300x200/E0E0E0/333333?text=手机挂绳';">
                    <h3>通通手机挂绳</h3>
                    <p class="product-item-short-desc">实用通通手机挂绳，解放双手，时尚便捷。</p>
                    <p class="static-description">这是一款实用又时尚的通通主题手机挂绳。挂绳主体为红白相间的编织绳，上面印有连续的通通头像图案。连接手机的部分有一个可爱的通通公仔头像作为装饰和固定扣，造型萌趣。可以有效防止手机滑落，解放双手。</p>
                    <p class="product-item-price">¥25</p>
                </div>
                <div class="product-item" onclick="showProductDetail(this)" data-price="¥35" data-name="通通基站徽章" 
                     data-description="这是一套通通漫游城市系列徽章，共四枚，装在一个橙色的礼盒中。每枚徽章都呈现了通通吉祥物与中国不同城市地标的组合，例如通通与北京天坛、通通与上海东方明珠、通通与广州塔以及通通与成都大熊猫。徽章造型各异，色彩鲜艳，制作精美，富有纪念意义。"
                     data-img-src="文创产品/0918_01_四方基站徽章(1).jpg">
                    <img src="文创产品/0918_01_四方基站徽章(1).jpg" alt="通通基站徽章" onerror="this.alt='基站徽章图片'; this.src='https://placehold.co/300x200/E0E0E0/333333?text=基站徽章';">
                    <h3>通通基站徽章</h3>
                    <p class="product-item-short-desc">创意四方基站徽章，联通精神，随身佩戴。</p>
                    <p class="static-description">这是一套通通漫游城市系列徽章，共四枚，装在一个橙色的礼盒中。每枚徽章都呈现了通通吉祥物与中国不同城市地标的组合，例如通通与北京天坛、通通与上海东方明珠、通通与广州塔以及通通与成都大熊猫。徽章造型各异，色彩鲜艳，制作精美，富有纪念意义。</p>
                    <p class="product-item-price">¥35</p>
                </div>
                <div class="product-item" onclick="showProductDetail(this)" data-price="¥19" data-name="通通香卡" 
                     data-description="这是一款通通主题的香卡。卡片主体为橙色调，印有可爱的通通形象，背景是抽象的彩色能量流线条，充满动感。卡片上印有'通通香卡'字样，并注明可用于车内、衣柜、房间扩香。设计清新活泼，能带来愉悦的香气体验。"
                     data-img-src="文创产品/0918_01_香卡(1).jpg">
                    <img src="文创产品/0918_01_香卡(1).jpg" alt="通通香卡" onerror="this.alt='香卡图片'; this.src='https://placehold.co/300x200/E0E0E0/333333?text=香卡';">
                    <h3>通通香卡</h3>
                    <p class="product-item-short-desc">清新通通主题香卡，怡人香气，点缀空间。</p>
                    <p class="static-description">这是一款通通主题的香卡。卡片主体为橙色调，印有可爱的通通形象，背景是抽象的彩色能量流线条，充满动感。卡片上印有'通通香卡'字样，并注明可用于车内、衣柜、房间扩香。设计清新活泼，能带来愉悦的香气体验。</p>
                    <p class="product-item-price">¥19</p>
                </div>
                <div class="product-item" onclick="showProductDetail(this)" data-price="¥39" data-name="通通旋转钥匙扣" 
                     data-description="这款是设计独特的通通旋转幸运钥匙扣。钥匙扣外圈为红色，饰有精美的金色传统回纹图案和一圈闪亮的仿水钻。中央部分是一个可以360度旋转的金色通通小公仔，造型活泼可爱。整体工艺精致，寓意吉祥，兼具趣味性和装饰性。"
                     data-img-src="文创产品/0918_01_旋转款钥匙扣.jpg">
                    <img src="文创产品/0918_01_旋转款钥匙扣.jpg" alt="通通旋转钥匙扣" onerror="this.alt='旋转钥匙扣图片'; this.src='https://placehold.co/300x200/E0E0E0/333333?text=旋转钥匙扣';">
                    <h3>通通旋转钥匙扣</h3>
                    <p class="product-item-short-desc">独特旋转设计钥匙扣，趣味十足，个性选择。</p>
                    <p class="static-description">这款是设计独特的通通旋转幸运钥匙扣。钥匙扣外圈为红色，饰有精美的金色传统回纹图案和一圈闪亮的仿水钻。中央部分是一个可以360度旋转的金色通通小公仔，造型活泼可爱。整体工艺精致，寓意吉祥，兼具趣味性和装饰性。</p>
                    <p class="product-item-price">¥39</p>
                </div>
            </div>
        </div>
        <button onclick="navigateTo('section-draw')" class="button-primary mt-8">参与幸运抽奖</button>
    </section>

    <section id="section-draw" class="section bg-yellow-100">
        <h2 class="text-3xl font-bold text-yellow-700 mb-6">幸运大抽奖</h2>
        <img src="lihe.png" alt="抽奖礼盒" class="w-40 h-40 md:w-48 md:h-48 rounded-lg shadow-lg mb-8" onerror="this.alt='礼盒图片'; this.style.backgroundColor='#ccc';">
        <p id="draw-result" class="text-xl text-gray-700 mb-8">点击按钮，抽取你的专属幸运！</p>
        <button id="draw-button" onclick="performDraw()" class="button-primary bg-yellow-500 hover:bg-yellow-600 text-lg">立即抽奖</button>
        <button onclick="navigateTo('section-cta')" class="button-primary mt-8">了解更多</button>
    </section>

    <section id="section-maze" class="section bg-purple-100">
        <h2 class="text-3xl font-bold text-purple-700 mb-6">通通闯迷宫</h2>

        <div class="w-[300px] mx-auto relative mb-2"> 
            <div id="maze-game-music-toggle" class="music-toggle-button absolute top-[40px] right-0 z-10">
                <img src="music_on.png" alt="Music On" onerror="this.parentElement.innerHTML = '<span style=\'font-size:12px;\'>🎵On</span>';">
            </div>
        </div>
        
        <p class="text-lg text-gray-700 mb-2">帮助通通找到中国结！(使用下方按钮)</p>
        <p class="game-timer-info">用时: <span id="maze-time-display">0</span> 秒</p>
        <div class="maze-canvas-wrapper">
            <canvas id="mazeCanvas" width="300" height="300"></canvas>
        </div>

        <div id="maze-game-controls" class="mt-4 md:mt-4">
            <button id="start-maze-btn" onclick="startMazeGame()" class="button-primary bg-purple-600 hover:bg-purple-700 text-lg">开始游戏</button>
            <button id="maze-to-products-btn" onclick="navigateTo('section-products')" class="button-primary bg-purple-600 hover:bg-purple-700 mt-0 ml-2 text-lg" style="display:none;">查看文创产品</button>
        </div>

        <div id="maze-controls-mobile" class="mt-3 grid grid-cols-3 gap-2 justify-items-center items-center w-max mx-auto md:hidden" style="width: calc(60px * 3 + 0.5rem * 2);">
            <div></div> <button class="maze-arrow-button" data-direction="up" aria-label="向上移动">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-8 h-8"><path stroke-linecap="round" stroke-linejoin="round" d="M12 19.5v-15m0 0l-6.75 6.75M12 4.5l6.75 6.75" /></svg>
            </button>
            <div></div> <button class="maze-arrow-button" data-direction="left" aria-label="向左移动">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-8 h-8"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 12h-15m0 0l6.75 6.75M4.5 12l6.75-6.75" /></svg>
            </button>
            <div class="w-[60px] h-[60px]"></div> <button class="maze-arrow-button" data-direction="right" aria-label="向右移动">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-8 h-8"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75" /></svg>
            </button>
            <div></div> <button class="maze-arrow-button" data-direction="down" aria-label="向下移动">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-8 h-8"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m0 0l6.75-6.75M12 19.5l-6.75-6.75" /></svg>
            </button>
            <div></div> </div>
    </section>

    <section id="section-match-game" class="section bg-green-100">
        <h1>通通文创消消乐</h1>
        <div class="desc">点击交换相邻的文创产品图片，三个及以上相同即可消除，快来体验文创魅力吧！</div>

        <div class="stats-container">
            <div id="score">分数：0</div>
            <div id="timer">剩余时间：60秒</div>
            <div id="hint-count-display">提示：2次</div>
            <div id="match-game-music-toggle" class="music-toggle-button">
                <img src="music_on.png" alt="Music On" onerror="this.parentElement.innerHTML = '<span style=\'font-size:12px;\'>🎵On</span>';">
            </div>
        </div>

        <div class="controls">
            <button id="action-btn" class="game-button">开始游戏</button>
            <button id="hint-btn" class="game-button">提示</button>
            <button id="match-game-to-products-btn" style="display:none;">查看文创产品</button>
        </div>

        <div id="game-board">
            </div>

        <div class="message-box-overlay" id="message-box-overlay">
            <div class="message-box">
                <p id="message-box-text"></p>
                <button id="message-box-ok">好</button>
            </div>
        </div>
    </section>


    <section id="section-cta" class="section bg-green-100">
        <h2 class="text-3xl font-bold text-green-700 mb-6">感谢参与！</h2>
        <img src="liantong.png" alt="感谢通通" class="w-auto h-20 rounded-lg shadow-lg mb-8" onerror="this.alt='联通Logo'; this.style.backgroundColor='#ccc';">
        <p class="text-lg text-gray-700 mb-8">关注中国联通，获取更多精美文创资讯和优惠活动！</p>
        <a href="https://m.10010.com/scaffold-show/subject/99p8r185qFL?isSupportPc=true" target="_blank" class="button-primary bg-green-500 hover:bg-green-600 text-lg mb-4">访问官方商城</a>
        <button onclick="showQrCodeModal()" class="button-primary bg-blue-500 hover:bg-blue-600 text-lg">关注我们</button>
        <button onclick="navigateTo('section-welcome')" class="button-primary bg-gray-500 hover:bg-gray-600 mt-8">重新开始</button>
    </section>

    <div id="messageModal" class="modal">
        <div class="modal-content">
            <button class="modal-close-button" onclick="this.parentElement.parentElement.style.display='none'; updateBackButtonVisibility();">&times;</button>
            <h3 id="modalTitle">提示</h3>
            <p id="modalMessage">这是一条消息。</p>
            <button id="modalCloseButton" class="button-primary">知道了</button>
        </div>
    </div>

    <div id="productDetailModal" class="modal">
        <div class="modal-content">
            <button class="modal-close-button" onclick="closeProductDetailModal()">&times;</button>
            <img id="productDetailImage" src="" alt="产品图片" class="mb-4" onerror="this.src='https://placehold.co/400x300/F0F0F0/AAAAAA?text=产品图片加载失败'; this.alt='产品图片占位图';">
            <h3 id="productDetailName" class="text-2xl font-bold text-orange-600 mb-2">产品名称</h3>
            
            <div id="ai-description-loader" class="text-sm text-gray-500 my-2" style="display: none;">✨ 通通正在为产品生成更生动描述...</div>
            <p id="productDetailDescription" class="text-gray-700 mb-3"></p> 
            
            <p id="productDetailPrice" class="text-xl font-semibold text-orange-700 mb-6">价格</p>
            <button id="productDetailBuyButton" class="button-primary w-full">立即购买</button>
        </div>
    </div>

    <div id="qrCodeModal" class="modal">
        <div class="modal-content flex flex-col items-center">
            <h3 id="qrCodeModalTitle" class="text-xl font-semibold text-blue-600 mb-4">感谢您关注中国联通官方微信公众号！</h3>
            <img id="qrCodeImage" src="gzh.jpg" alt="关注我们二维码" onerror="this.alt='二维码图片'; this.src='https://placehold.co/280x280/EEEEEE/333333?text=二维码';">
            <button onclick="closeQrCodeModal()" class="button-primary bg-blue-500 hover:bg-blue-600 mt-4">关闭</button>
        </div>
    </div>


    <script>
        // --- Global State and Configuration ---
        let currentSection = 'section-welcome'; 
        let navigationHistory = []; 
        let clickerGameCompletedOnce = false; 
        let mazeGameWonOnce = false; 
        window.matchGameInitialized = false; 
        window.matchGameContext = {
            isMatchGameMusicOn: true, 
            hasEverCompletedMatchGame: false, 
            matchGameCompletedOnce: false 
        };

        // --- DOM Element References ---
        const hotspotPopup = document.getElementById('hotspot-popup');
        const hotspotTitle = document.getElementById('hotspot-title');
        const hotspotText = document.getElementById('hotspot-text');
        const messageModal = document.getElementById('messageModal');
        const modalTitleElem = document.getElementById('modalTitle');
        const modalMessageElem = document.getElementById('modalMessage');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const qrCodeModal = document.getElementById('qrCodeModal');
        const productDetailModal = document.getElementById('productDetailModal');
        const productDetailImage = document.getElementById('productDetailImage');
        const productDetailName = document.getElementById('productDetailName');
        const productDetailDescription = document.getElementById('productDetailDescription');
        const productDetailPrice = document.getElementById('productDetailPrice');
        const productDetailBuyButton = document.getElementById('productDetailBuyButton');
        const aiDescriptionLoader = document.getElementById('ai-description-loader'); 
        const enhanceHotspotBtn = document.getElementById('enhance-hotspot-btn');
        const aiHotspotContent = document.getElementById('ai-hotspot-content');
        const aiHotspotLoading = document.getElementById('ai-hotspot-loading');
        const tongtongChatModalContainer = document.getElementById('tongtong-chat-modal-container');
        const chatHistoryModalEl = document.getElementById('chat-history-modal');
        const chatInputModalEl = document.getElementById('chat-input-modal');
        const sendChatModalBtn = document.getElementById('send-chat-modal-btn');
        const closeChatModalBtn = document.getElementById('close-chat-modal-btn');
        const chatLoadingModalEl = document.getElementById('chat-loading-modal');
        const tongtongChatHistory = []; 
        const tongtongChatToggleButton = document.getElementById('tongtong-chat-toggle-button');

        // Fallback descriptions for products if AI generation fails
        const finalFallbackProductDescriptions = {
            "通通保温杯": "这款通通主题保温杯，采用优质不锈钢材料，长效保温保冷。杯身印有可爱的通通形象和城市剪影，时尚又实用。无论是热茶还是冰饮，它都能锁住温度，让你随时畅饮。带上它，让通通的温暖陪伴你的每一天！",
            "通通充电线": "通通三合一快速充电线，萌趣的通通公仔头设计，不仅可爱还能保护接口。一线多用，兼容苹果、安卓、Type-C设备，满足你的多种充电需求。优质编织线身，耐用防缠绕。让通通为你注入满满电力，告别电量焦虑！",
            "通通地球钥匙扣": "通通地球探索钥匙扣，以旋转的地球和手持笔记本电脑的通通为设计元素，镶嵌闪亮水钻，寓意联通世界、连接未来。金属质感，精致耐用，不仅是钥匙的好伴侣，也是包包装饰的亮点。让通通带你环游世界，探索无限可能！",
            "通通毛绒玩具": "超萌的通通吉祥物毛绒公仔来啦！采用亲肤柔软短毛绒，填充饱满Q弹，手感超舒适。经典的通通造型，大眼睛和标志性的触角，可爱到犯规！无论是抱在怀里还是作为摆件，都能给你带来好心情。快把可爱的通通带回家吧！",
            "金色通通手办": "限量珍藏版金色通通手办，闪耀的金色涂装，让通通更显尊贵与活力。造型生动，细节精致，底座稳固，是桌面上一道亮丽的风景线。不仅是联通粉丝的必备收藏，也是一份充满心意和科技感的独特好礼。",
            "通通手机挂绳": "通通定制款手机挂绳，宽版设计舒适不勒手，印有可爱的通通图案序列。搭配萌趣的通通公仔头固定扣，既实用又时尚。解放你的双手，让手机随身携带更安全便捷。多种用法，可挂手机、工牌、钥匙等。",
            "通通基站徽章": "通通漫游城市系列徽章套装，一套四枚，分别展现了通通在不同城市地标（如北京天坛、上海东方明珠、广州塔、成都大熊猫基地）的可爱形象。设计精巧，色彩鲜明，是收藏和佩戴的佳品，象征着联通信号覆盖神州大地。",
            "通通香卡": "通通主题定制香卡，散发持久淡雅清香。可爱的通通形象搭配缤纷的彩虹元素，为你带来视觉与嗅觉的双重愉悦。适用于车内、衣柜、房间等多种场景，轻松去除异味，营造清新舒适的氛围。让通通的芬芳伴你左右。",
            "通通旋转钥匙扣": "通通幸运转转钥匙扣，外圈采用中国传统回纹镂空设计，镶嵌闪亮水钻，中间是可爱的金色通通公仔，可以自由旋转。寓意时来运转，好运连连。金属材质，工艺精湛，是钥匙扣也是一个有趣的掌上小玩具。"
        };


        // --- Modal Functionality ---
        if (modalCloseButton) {
            modalCloseButton.onclick = () => {
                if (messageModal) messageModal.style.display = 'none';
                updateBackButtonVisibility(); 
            };
        }

        function showMessage(title, message) {
            if (modalTitleElem) modalTitleElem.textContent = title;
            if (modalMessageElem) modalMessageElem.textContent = message;
            if (messageModal) messageModal.style.display = 'flex'; 
            updateBackButtonVisibility(); 
        }

        // --- DeepSeek API Integration ---
        async function callDeepSeekAPI(prompt, isChat = false) {
            let deepSeekMessages = [];
            const systemMessageContent = "你是中国联通的吉祥物“通通”，一个友好、乐于助人的人工智能助手。"; 

            if (isChat) {
                deepSeekMessages = tongtongChatHistory.map(msg => ({
                    role: msg.role === 'model' ? 'assistant' : msg.role, 
                    content: msg.parts[0].text 
                }));
                deepSeekMessages.push({ role: "user", content: prompt });
            } else {
                deepSeekMessages.push({ role: "system", content: systemMessageContent });
                deepSeekMessages.push({ role: "user", content: prompt });
            }

            if (deepSeekMessages.length === 0 || deepSeekMessages[0].role !== 'system') {
                deepSeekMessages.unshift({ role: "system", content: systemMessageContent });
            }

            const payload = {
                model: "deepseek-chat", 
                messages: deepSeekMessages,
                stream: false 
            };

            const apiKey = "sk-49d0e05218fd4ed0b25384aa6847478a"; 
            const apiUrl = "https://api.deepseek.com/chat/completions"; 

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}` 
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("DeepSeek API Error:", errorData);
                    const message = errorData.error && errorData.error.message ? errorData.error.message : `API请求失败，状态码: ${response.status}`;
                    if (isChat && !navigator.onLine) {
                        return { error: "请联网后再与通通聊天" };
                    }
                    return { error: `AI内容生成失败：${message}` };
                }

                const result = await response.json();

                if (result.choices && result.choices.length > 0 && result.choices[0].message && result.choices[0].message.content) {
                    const generatedText = result.choices[0].message.content;
                    if (isChat) {
                        tongtongChatHistory.push({ role: "model", parts: [{ text: generatedText }] });
                    }
                    return { text: generatedText };
                } else {
                    console.error("Unexpected response structure from DeepSeek API:", result);
                    if (isChat && !navigator.onLine) {
                         return { error: "请联网后再与通通聊天" };
                    }
                    return { error: "AI未能生成内容，请稍后再试。" };
                }
            } catch (error) {
                console.error("Error calling DeepSeek API:", error);
                if (isChat && !navigator.onLine) {
                    return { error: "请联网后再与通通聊天" };
                }
                return { error: "调用AI服务时发生网络错误。" };
            }
        }

        async function getAIEnhancedHotspotInfo(title, originalText) {
            if (aiHotspotContent) aiHotspotContent.innerHTML = ''; 
            if (aiHotspotLoading) aiHotspotLoading.style.display = 'block'; 
            const prompt = `你是一个活泼可爱的吉祥物“通通”的伙伴。请用生动有趣的方式，详细解读一下“通通”的'${title}'这个部分，它象征着：'${originalText}'。请用大约50-100字展开描述，让小朋友和家长都喜欢。`;
            const result = await callDeepSeekAPI(prompt); 
            if (aiHotspotLoading) aiHotspotLoading.style.display = 'none'; 
            if (aiHotspotContent) {
                if (result.error) {
                    aiHotspotContent.innerHTML = `<p class="text-red-500">${result.error}</p>`; 
                } else {
                    aiHotspotContent.innerHTML = `<p class="text-sm text-gray-700 mt-2 p-3 bg-orange-50 rounded-lg shadow-inner border border-orange-200">${result.text.replace(/\n/g, '<br>')}</p>`;
                }
            }
        }

        async function getAIEnhancedProductDescription(productNameKey, imageBasedDesc, descriptionElement, loadingElement, finalFallbackText) {
            const prompt = `你是一位优秀的联通文创产品营销专家。这里有一款产品叫做“${productNameKey}”。关于这款产品的外观和特点，我们已经有了一段基于图片的详细描述：“${imageBasedDesc}”。请你基于这段详细描述，用更加生动、富有吸引力且略带趣味性的语言，进一步润色和创作一段大约50-100字的推广文案，突出产品的亮点和带给用户的美好体验，让人一听就想拥有它。请直接输出最终的推广文案，不要包含任何额外的解释性文字或开场白，也不要重复“${imageBasedDesc}”中的原句。`;
            
            const result = await callDeepSeekAPI(prompt); 

            if (loadingElement) loadingElement.style.display = 'none'; 

            if (descriptionElement) {
                if (result.error) {
                    descriptionElement.innerHTML = finalFallbackText.replace(/\n/g, '<br>');
                } else {
                    descriptionElement.innerHTML = result.text.replace(/\n/g, '<br>');
                }
            }
        }

        // --- Chat Modal Functionality ---
        function addMessageToChatModalUI(message, sender) {
            if (!chatHistoryModalEl) return; 
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message-modal'); 

            if (sender === 'user') {
                messageDiv.classList.add('user-message-modal'); 
                messageDiv.innerHTML = message.replace(/\n/g, '<br>'); 
            } else { 
                messageDiv.classList.add('ai-message-modal'); 
                const avatarImg = document.createElement('img');
                avatarImg.src = 'xia.png'; 
                avatarImg.alt = '通通头像';
                avatarImg.classList.add('chat-avatar');
                avatarImg.onerror = function() { this.style.display='none'; }; 
                messageDiv.appendChild(avatarImg);
                const textSpan = document.createElement('span');
                textSpan.classList.add('message-text-modal');
                textSpan.innerHTML = message.replace(/\n/g, '<br>');
                messageDiv.appendChild(textSpan);
            }
            
            chatHistoryModalEl.appendChild(messageDiv); 
            chatHistoryModalEl.scrollTop = chatHistoryModalEl.scrollHeight; 
        }

        async function handleSendChatModalMessage() {
            if (!chatInputModalEl || !sendChatModalBtn || !chatLoadingModalEl) return;
            const userQuery = chatInputModalEl.value.trim();
            if (!userQuery) return; 

            addMessageToChatModalUI(userQuery, 'user'); 
            chatInputModalEl.value = ''; 
            chatLoadingModalEl.style.display = 'block'; 
            sendChatModalBtn.disabled = true; 
            
            let result = await callDeepSeekAPI(userQuery, true); 

            if (result.error) {
                addMessageToChatModalUI(result.error, 'ai'); 
            } else {
                addMessageToChatModalUI(result.text, 'ai'); 
            }

            chatLoadingModalEl.style.display = 'none'; 
            sendChatModalBtn.disabled = false; 
            chatInputModalEl.focus(); 
        }

        if (sendChatModalBtn) {
            sendChatModalBtn.onclick = handleSendChatModalMessage;
        }
        if (chatInputModalEl) {
            chatInputModalEl.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') { 
                    handleSendChatModalMessage();
                }
            });
        }
        
        if (tongtongChatToggleButton && tongtongChatModalContainer) {
            tongtongChatToggleButton.onclick = () => {
                const isHidden = tongtongChatModalContainer.style.display === 'none';
                tongtongChatModalContainer.style.display = isHidden ? 'flex' : 'none'; 
                tongtongChatToggleButton.textContent = isHidden ? '💬 收起聊天框' : '💬 和通通聊聊天';
                updateBackButtonVisibility(); 
            };
        }
        if (closeChatModalBtn && tongtongChatModalContainer) {
            closeChatModalBtn.onclick = () => {
                tongtongChatModalContainer.style.display = 'none';
                if (tongtongChatToggleButton) tongtongChatToggleButton.textContent = '💬 和通通聊聊天';
                updateBackButtonVisibility();
            };
        }


        // --- Navigation and UI State Management ---
        function updateBackButtonVisibility() {
            const backButton = document.getElementById('global-back-button');
            if (!backButton) return;

            const isHotspotVisible = hotspotPopup && hotspotPopup.style.display === 'block';
            const isMessageModalVisible = messageModal && messageModal.style.display === 'flex';
            const isProductDetailVisible = productDetailModal && productDetailModal.style.display === 'flex';
            const isQrCodeModalVisible = qrCodeModal && qrCodeModal.style.display === 'flex';
            const gameMessageBoxOverlay = document.getElementById('message-box-overlay');
            const isGameModalVisible = gameMessageBoxOverlay && gameMessageBoxOverlay.classList.contains('visible');
            const isChatModalVisible = tongtongChatModalContainer && tongtongChatModalContainer.style.display === 'flex'; 

            const isAnyModalVisible = isHotspotVisible || isMessageModalVisible || isProductDetailVisible || isQrCodeModalVisible || isGameModalVisible || isChatModalVisible;

            // Handle global back button state
            if (currentSection !== 'section-welcome' && !isAnyModalVisible) {
                backButton.style.display = 'flex'; 
                backButton.classList.remove('disabled'); 
            } else if (currentSection !== 'section-welcome' && isAnyModalVisible) {
                backButton.style.display = 'flex'; 
                backButton.classList.add('disabled'); 
            } else {
                backButton.style.display = 'none'; 
                backButton.classList.remove('disabled');
            }

            // MODIFIED: Handle disabling/enabling interactive elements on section-explore
            const exploreInteractives = document.querySelectorAll('#section-explore .explore-interactive');
            if (currentSection === 'section-explore') {
                if (isAnyModalVisible) { // If any modal is visible ON THE EXPLORE PAGE
                    exploreInteractives.forEach(el => {
                        el.style.pointerEvents = 'none';
                        el.style.opacity = '0.4';
                        el.style.filter = 'blur(1px)';
                    });
                } else {
                    exploreInteractives.forEach(el => {
                        el.style.pointerEvents = '';
                        el.style.opacity = '';
                        el.style.filter = '';
                    });
                }
            } else { // If not on explore section, ensure its elements are interactive
                 exploreInteractives.forEach(el => {
                    el.style.pointerEvents = '';
                    el.style.opacity = '';
                    el.style.filter = '';
                });
            }
        }

        function resetClickerGame() {
            gameActive = false; 
            clearInterval(gameInterval); 
            clearInterval(tongtongSpawnInterval); 
            gameScore = 0; gameTime = 10; 
            if (gameScoreDisplay) gameScoreDisplay.textContent = gameScore;
            if (gameTimerDisplay) gameTimerDisplay.textContent = gameTime;
            if (startGameBtn) {
                startGameBtn.textContent = clickerGameCompletedOnce ? '再玩一次' : '开始游戏';
                startGameBtn.disabled = false;
            }
            if (toProductsBtn) toProductsBtn.style.display = clickerGameCompletedOnce ? 'inline-block' : 'none';
            if (gameArea) gameArea.querySelectorAll('.game-tongtong').forEach(el => el.remove());
        }

        function resetMazeGame() {
            mazeGameActive = false; 
            clearInterval(mazeTimerInterval); 
            if (mazeBackgroundMusic) { mazeBackgroundMusic.pause(); mazeBackgroundMusic.currentTime = 0; }
            if (mazeWinMusic) { mazeWinMusic.pause(); mazeWinMusic.currentTime = 0; }
            mazeTimeElapsed = 0; 
            if (updateMazeTimerDisplay) updateMazeTimerDisplay(); 
            if (startMazeBtn) {
                startMazeBtn.textContent = mazeGameWonOnce ? '再玩一次' : '开始游戏';
                startMazeBtn.disabled = false;
            }
            if (mazeToProductsBtn) mazeToProductsBtn.style.display = mazeGameWonOnce ? 'inline-block' : 'none';
            if (mazeCtx && mazeCanvas) mazeCtx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height); 
        }

        function cleanupMatchGame() {
            const gameContext = window.matchGameContext;
            if (gameContext.timerInterval) { clearInterval(gameContext.timerInterval); gameContext.timerInterval = null; }

            if (gameContext.gameStarted && !gameContext.matchGameCompletedOnce && !gameContext.isFinishingSequence) {
                gameContext.gameStarted = false;
            }
            
            if (typeof gameContext.setGameActive === 'function') gameContext.setGameActive(false); 
            if (typeof gameContext.resetHint === 'function') gameContext.resetHint(); 

            const matchGameMusicIcon = gameContext.matchGameMusicToggleBtn ? gameContext.matchGameMusicToggleBtn.querySelector('img') : null;
            if (matchGameMusicIcon) {
                 const iconSrc = gameContext.isMatchGameMusicOn ? 'music_on.png' : 'music_off.png';
                 matchGameMusicIcon.src = iconSrc;
                 matchGameMusicIcon.alt = gameContext.isMatchGameMusicOn ? 'Music On' : 'Music Off';
                 matchGameMusicIcon.onerror = () => { 
                    matchGameMusicIcon.parentElement.innerHTML = `<span style="font-size:12px;">🎵${gameContext.isMatchGameMusicOn ? 'On':'Off'}</span>`;
                 };
            }
        }

        function navigateTo(sectionId, isBackNavigation = false) {
            const nextSection = document.getElementById(sectionId); 
            if (nextSection) {
                const currentActiveSectionElement = document.querySelector('.section.active-section'); 
                
                if (currentActiveSectionElement) {
                    if (!isBackNavigation && currentSection !== sectionId) {
                        navigationHistory.push(currentSection);
                    }

                    if (currentActiveSectionElement.id === 'section-game') resetClickerGame();
                    else if (currentActiveSectionElement.id === 'section-maze') resetMazeGame();
                    else if (currentActiveSectionElement.id === 'section-match-game') cleanupMatchGame(); 
                    
                    currentActiveSectionElement.classList.remove('active-section'); 
                }

                if (sectionId === 'section-game') resetClickerGame(); 
                else if (sectionId === 'section-maze') resetMazeGame(); 
                else if (sectionId === 'section-match-game') {
                    if (!window.matchGameInitialized) { 
                        initMatchGame(); window.matchGameInitialized = true;
                    }
                    if (typeof window.matchGameContext.prepareForView === 'function') {
                        window.matchGameContext.prepareForView(); 
                    }
                } else if (sectionId === 'section-explore') { 
                    if (tongtongChatModalContainer) tongtongChatModalContainer.style.display = 'none'; 
                    if (tongtongChatToggleButton) tongtongChatToggleButton.textContent = '💬 和通通聊聊天';
                }


                nextSection.classList.add('active-section'); 
                currentSection = sectionId; 
                window.scrollTo(0, 0); 
                updateBackButtonVisibility(); 
            } else {
                console.error("Section with ID " + sectionId + " not found.");
            }
        }

        function navigateBack() {
            const backButton = document.getElementById('global-back-button');
            if (backButton && backButton.classList.contains('disabled')) return; 

            if (navigationHistory.length > 0) {
                const previousSectionId = navigationHistory.pop(); 
                navigateTo(previousSectionId, true); 
            } else {
                let fallbackSectionId = 'section-welcome'; 
                if (currentSection === 'section-explore') fallbackSectionId = 'section-welcome';
                else if (['section-game', 'section-maze', 'section-match-game'].includes(currentSection)) fallbackSectionId = 'section-explore';
                else if (currentSection === 'section-products') fallbackSectionId = 'section-explore'; 
                else if (currentSection === 'section-draw') fallbackSectionId = 'section-products';
                else if (currentSection === 'section-cta') fallbackSectionId = 'section-draw';

                if (currentSection !== fallbackSectionId && currentSection !== 'section-welcome') {
                    navigateTo(fallbackSectionId, true);
                } else if (currentSection !== 'section-welcome' && fallbackSectionId === 'section-welcome') {
                    navigateTo('section-welcome', true);
                }
            }
        }

        function showHotspotInfo(title, text) {
            if(hotspotTitle) hotspotTitle.textContent = title;
            if(hotspotText) hotspotText.textContent = text;
            
            if(aiHotspotContent) aiHotspotContent.innerHTML = '';
            if(aiHotspotLoading) aiHotspotLoading.style.display = 'none';

            const noAIHotspots = ['通通的触角', '通通的笑脸', '拟人化外观']; 
            if (noAIHotspots.includes(title)) {
                if(enhanceHotspotBtn) enhanceHotspotBtn.style.display = 'none';
            } else {
                if(enhanceHotspotBtn) {
                    enhanceHotspotBtn.style.display = 'block'; 
                    enhanceHotspotBtn.onclick = () => getAIEnhancedHotspotInfo(title, text);
                }
            }
            if(hotspotPopup) hotspotPopup.style.display = 'block'; 
            updateBackButtonVisibility(); 
        }
        function closeHotspotInfo() {
            if(hotspotPopup) hotspotPopup.style.display = 'none'; updateBackButtonVisibility();
        }

        // --- Clicker Game Logic ---
        const gameArea = document.getElementById('game-area');
        const gameScoreDisplay = document.getElementById('game-score');
        const gameTimerDisplay = document.getElementById('game-timer');
        const startGameBtn = document.getElementById('start-game-btn');
        const toProductsBtn = document.getElementById('to-products-btn'); 
        let gameScore = 0, gameTime = 10, gameInterval, tongtongSpawnInterval, gameActive = false;
        const clickSound = new Audio('ks.mp3'); 
        let isClickGameMusicOn = true; 
        const clickGameMusicToggleBtn = document.getElementById('click-game-music-toggle');
        const clickGameMusicIcon = clickGameMusicToggleBtn ? clickGameMusicToggleBtn.querySelector('img') : null;

        if (clickGameMusicToggleBtn && clickGameMusicIcon) {
            clickGameMusicToggleBtn.onclick = () => {
                isClickGameMusicOn = !isClickGameMusicOn;
                const newIconSrc = isClickGameMusicOn ? 'music_on.png' : 'music_off.png';
                clickGameMusicIcon.src = newIconSrc; clickGameMusicIcon.alt = isClickGameMusicOn ? 'Music On' : 'Music Off';
                clickGameMusicIcon.onerror = () => { 
                    clickGameMusicIcon.parentElement.innerHTML = `<span style="font-size:12px;">🎵${isClickGameMusicOn ? 'On':'Off'}</span>`;
                };
            };
        }

        function startGame() {
            gameScore = 0; gameTime = 10; gameActive = true; 
            if (gameScoreDisplay) gameScoreDisplay.textContent = gameScore;
            if (gameTimerDisplay) gameTimerDisplay.textContent = gameTime;
            if (startGameBtn) { startGameBtn.textContent = '游戏中...'; startGameBtn.disabled = true; }
            if (toProductsBtn) toProductsBtn.style.display = 'none'; 
            if (gameArea) gameArea.querySelectorAll('.game-tongtong').forEach(el => el.remove()); 
            
            gameInterval = setInterval(() => {
                gameTime--; 
                if(gameTimerDisplay) gameTimerDisplay.textContent = gameTime;
                if (gameTime <= 0) endGame(true); 
            }, 1000);
            
            tongtongSpawnInterval = setInterval(spawnTongTong, 700); 
            spawnTongTong(); 
        }

        function spawnTongTong() {
            if (!gameActive || gameTime <= 0 || !gameArea) return; 
            if (gameArea.querySelectorAll('.game-tongtong').length >= 3) return; 

            const tongtongElement = document.createElement('div');
            tongtongElement.classList.add('game-tongtong');
            tongtongElement.onerror = function() {
                this.style.backgroundImage = 'none'; this.style.backgroundColor = '#FF6600'; 
                const placeholderText = document.createElement('span');
                placeholderText.textContent = '通'; placeholderText.style.color = 'white';
                placeholderText.style.fontSize = '30px'; placeholderText.style.lineHeight = '60px';
                this.appendChild(placeholderText);
            };

            const gameAreaRect = gameArea.getBoundingClientRect(); const tongtongSize = 60;
            const randomX = Math.max(0, Math.random() * (gameAreaRect.width - tongtongSize));
            const randomY = Math.max(0, Math.random() * (gameAreaRect.height - tongtongSize));
            tongtongElement.style.left = randomX + 'px'; tongtongElement.style.top = randomY + 'px';
            
            tongtongElement.onclick = () => {
                if (gameActive && gameTime > 0) {
                    gameScore++; 
                    if(gameScoreDisplay) gameScoreDisplay.textContent = gameScore;
                    if (isClickGameMusicOn && clickSound) { clickSound.currentTime = 0; clickSound.play().catch(e => console.warn("Error playing click sound:", e)); }
                    tongtongElement.remove(); 
                }
            };
            gameArea.appendChild(tongtongElement);

            setTimeout(() => {
                if (tongtongElement.parentElement) { 
                    tongtongElement.style.opacity = '0'; 
                    setTimeout(() => tongtongElement.remove(), 300); 
                }
            }, 1000 + Math.random() * 200); 
        }

        function endGame(showModal = true) {
            gameActive = false; 
            clearInterval(gameInterval); clearInterval(tongtongSpawnInterval); 
            if(gameArea) gameArea.querySelectorAll('.game-tongtong').forEach(tt => tt.remove()); 
            
            if (showModal) {
                showMessage('游戏结束!', `太棒了！你获得了 ${gameScore} 分!`);
                clickerGameCompletedOnce = true; 
            } else { 
                updateBackButtonVisibility(); 
            }
            if(startGameBtn) { startGameBtn.textContent = '再玩一次'; startGameBtn.disabled = false; }
            if(toProductsBtn) toProductsBtn.style.display = clickerGameCompletedOnce ? 'inline-block' : 'none'; 
        }

        // --- Draw Section Logic ---
        const drawButton = document.getElementById('draw-button');
        const prizes = ["通通文创9折优惠券！", "通通限量版贴纸一套！", "联通5元话费抵扣券！", "通通专属手机壁纸下载！"];
        let hasDrawn = false; 
        function performDraw() {
            if (hasDrawn) { showMessage('提示', '您已经抽过奖啦，看看其他活动吧！'); return; }
            const prizeWon = prizes[Math.floor(Math.random() * prizes.length)]; 
            showMessage('抽奖结果', `恭喜你！抽中了：${prizeWon}`);
            if(drawButton) { drawButton.textContent = '已抽奖'; drawButton.disabled = true; }
            hasDrawn = true;
        }

        // --- Product Detail Modal Logic ---
        function showProductDetail(element) {
            if (!productDetailModal || !element || !element.dataset) return;
            
            if(productDetailImage) {
                productDetailImage.src = element.dataset.imgSrc || ''; 
            }
            const productNameKey = element.dataset.name || '产品名称'; 
            if(productDetailName) productDetailName.textContent = productNameKey;
            if(productDetailPrice) productDetailPrice.textContent = element.dataset.price || '价格待定';

            if (productDetailDescription) productDetailDescription.innerHTML = ''; 
            if (aiDescriptionLoader) aiDescriptionLoader.style.display = 'block'; 
            
            const imageBasedDesc = element.dataset.description || '暂无详细描述。'; 
            const finalFallbackText = finalFallbackProductDescriptions[productNameKey] || imageBasedDesc; 

            getAIEnhancedProductDescription(
                productNameKey, 
                imageBasedDesc, 
                productDetailDescription, 
                aiDescriptionLoader,
                finalFallbackText 
            );
            
            if(productDetailBuyButton) {
                productDetailBuyButton.onclick = () => {
                    showMessage('购买提示', `感谢您有兴趣购买 ${productNameKey}！此功能正在建设中。`);
                    closeProductDetailModal();
                };
            }
            productDetailModal.style.display = 'flex'; 
            updateBackButtonVisibility(); 
        }

        function closeProductDetailModal() {
            if(productDetailModal) productDetailModal.style.display = 'none'; updateBackButtonVisibility();
        }

        // --- QR Code Modal Logic ---
        function showQrCodeModal() { if (qrCodeModal) { qrCodeModal.style.display = 'flex'; updateBackButtonVisibility(); } }
        function closeQrCodeModal() { if (qrCodeModal) { qrCodeModal.style.display = 'none'; updateBackButtonVisibility(); } }


        // --- Maze Game Logic ---
        const mazeCanvas = document.getElementById('mazeCanvas');
        const mazeCtx = mazeCanvas ? mazeCanvas.getContext('2d') : null;
        const startMazeBtn = document.getElementById('start-maze-btn');
        const mazeToProductsBtn = document.getElementById('maze-to-products-btn');
        const mazeTimeDisplay = document.getElementById('maze-time-display');
        const mazeBackgroundMusic = new Audio('mggc.mp3'); 
        const mazeWinMusic = new Audio('mgcg.mp3'); 
        let isMazeMusicOn = true; 
        const mazeGameMusicToggleBtn = document.getElementById('maze-game-music-toggle');
        const mazeGameMusicIcon = mazeGameMusicToggleBtn ? mazeGameMusicToggleBtn.querySelector('img') : null;

        const playerMazeImgDefault = new Image(), playerMazeImgUp = new Image(), playerMazeImgDown = new Image(),
              playerMazeImgLeft = new Image(), playerMazeImgRight = new Image(), endMazeImg = new Image();
        playerMazeImgDefault.src = 'xia.png'; playerMazeImgUp.src = 'shang.png'; playerMazeImgDown.src = 'xia.png';
        playerMazeImgLeft.src = 'zuo.png'; playerMazeImgRight.src = 'you.png'; endMazeImg.src = 'zgj.png';
        let currentPlayerMazeImg = playerMazeImgDefault; 

        [playerMazeImgDefault, playerMazeImgUp, playerMazeImgDown, playerMazeImgLeft, playerMazeImgRight, endMazeImg].forEach(img => {
            img.onload = () => { if (currentSection === 'section-maze' && mazeGameActive && (img === currentPlayerMazeImg || img === endMazeImg)) drawMaze(); };
            img.onerror = () => { 
                console.warn(`Maze image ${img.src} failed to load.`);
                if (currentSection === 'section-maze' && mazeGameActive) drawMaze(); 
            };
        });

        if (mazeGameMusicToggleBtn && mazeGameMusicIcon) {
            mazeGameMusicToggleBtn.onclick = () => {
                isMazeMusicOn = !isMazeMusicOn;
                const newIconSrc = isMazeMusicOn ? 'music_on.png' : 'music_off.png';
                mazeGameMusicIcon.src = newIconSrc; mazeGameMusicIcon.alt = isMazeMusicOn ? 'Music On' : 'Music Off';
                mazeGameMusicIcon.onerror = () => { 
                    mazeGameMusicIcon.parentElement.innerHTML = `<span style="font-size:12px;">🎵${isMazeMusicOn ? 'On':'Off'}</span>`;
                };
                if (isMazeMusicOn) {
                    if (mazeGameActive && !(playerMazePos.x === endMazePos.x && playerMazePos.y === endMazePos.y)) { 
                        mazeBackgroundMusic.play().catch(e => console.warn("Error playing maze background music:", e));
                    }
                } else { 
                    if(mazeBackgroundMusic) mazeBackgroundMusic.pause(); 
                    if(mazeWinMusic) { mazeWinMusic.pause(); mazeWinMusic.currentTime = 0; }
                }
            };
        }

        let mazeGrid = [], playerMazePos = { x: 0, y: 0 }, endMazePos = { x: 0, y: 0 };
        const mazeCols = 10, mazeRows = 10; 
        let mazeCellSize, mazeTimerInterval, mazeTimeElapsed = 0, mazeGameActive = false;
        
        function updateMazeTimerDisplay() { if(mazeTimeDisplay) mazeTimeDisplay.textContent = mazeTimeElapsed; }
        
        function generateMaze(cols, rows) {
            mazeGrid = [];
            for (let r = 0; r < rows; r++) {
                mazeGrid[r] = [];
                for (let c = 0; c < cols; c++) {
                    mazeGrid[r][c] = { r: r, c: c, walls: { top: true, right: true, bottom: true, left: true }, visited: false };
                }
            }
            playerMazePos = { x: 0, y: 0 }; 
            endMazePos = { x: cols - 1, y: rows - 1 }; 

            let stack = []; 
            let current = mazeGrid[playerMazePos.y][playerMazePos.x];
            current.visited = true; 
            stack.push(current);

            while (stack.length > 0) {
                current = stack[stack.length - 1]; 
                let neighbors = []; 
                const {r, c} = current;
                if (r > 0 && !mazeGrid[r-1][c].visited) neighbors.push(mazeGrid[r-1][c]);
                if (c < cols-1 && !mazeGrid[r][c+1].visited) neighbors.push(mazeGrid[r][c+1]);
                if (r < rows-1 && !mazeGrid[r+1][c].visited) neighbors.push(mazeGrid[r+1][c]);
                if (c > 0 && !mazeGrid[r][c-1].visited) neighbors.push(mazeGrid[r][c-1]);

                if (neighbors.length > 0) {
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)]; 
                    if (next.r < current.r) { current.walls.top = false; next.walls.bottom = false; } 
                    else if (next.c > current.c) { current.walls.right = false; next.walls.left = false; } 
                    else if (next.r > current.r) { current.walls.bottom = false; next.walls.top = false; } 
                    else if (next.c < current.c) { current.walls.left = false; next.walls.right = false; } 
                    next.visited = true; 
                    stack.push(next); 
                } else { 
                    stack.pop(); 
                }
            }
            return mazeGrid;
        }
        
        function drawMaze() {
            if (!mazeCanvas || !mazeCtx || !mazeGrid || mazeGrid.length === 0) return;
            mazeCtx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height); 
            mazeCtx.strokeStyle = '#FFFFFF'; 
            mazeCtx.lineWidth = Math.max(2, Math.floor(mazeCellSize / 11)); 

            for (let r = 0; r < mazeRows; r++) {
                for (let c = 0; c < mazeCols; c++) {
                    if (!mazeGrid[r] || !mazeGrid[r][c]) continue; 
                    let cell = mazeGrid[r][c]; 
                    let x = c * mazeCellSize; 
                    let y = r * mazeCellSize;
                    if (cell.walls.top) { mazeCtx.beginPath(); mazeCtx.moveTo(x, y); mazeCtx.lineTo(x + mazeCellSize, y); mazeCtx.stroke(); }
                    if (cell.walls.right) { mazeCtx.beginPath(); mazeCtx.moveTo(x + mazeCellSize, y); mazeCtx.lineTo(x + mazeCellSize, y + mazeCellSize); mazeCtx.stroke(); }
                    if (cell.walls.bottom) { mazeCtx.beginPath(); mazeCtx.moveTo(x + mazeCellSize, y + mazeCellSize); mazeCtx.lineTo(x, y + mazeCellSize); mazeCtx.stroke(); }
                    if (cell.walls.left) { mazeCtx.beginPath(); mazeCtx.moveTo(x, y + mazeCellSize); mazeCtx.lineTo(x, y); mazeCtx.stroke(); }
                }
            }

            const imgPadding = mazeCellSize * 0.1; 
            const imgDrawSize = mazeCellSize * 0.8; 
            
            const playerImgToDraw = currentPlayerMazeImg || playerMazeImgDefault; 
            if (playerImgToDraw && playerImgToDraw.complete && playerImgToDraw.naturalWidth !== 0) {
                mazeCtx.drawImage(playerImgToDraw, playerMazePos.x * mazeCellSize + imgPadding, playerMazePos.y * mazeCellSize + imgPadding, imgDrawSize, imgDrawSize);
            } else { 
                mazeCtx.fillStyle = 'rgba(220, 38, 38, 0.8)'; 
                mazeCtx.fillRect(playerMazePos.x * mazeCellSize + imgPadding, playerMazePos.y * mazeCellSize + imgPadding, imgDrawSize, imgDrawSize);
            }
            
            const goalImgToDraw = endMazeImg;
            if (goalImgToDraw && goalImgToDraw.complete && goalImgToDraw.naturalWidth !== 0) {
                const endImgAspectRatio = goalImgToDraw.naturalWidth / goalImgToDraw.naturalHeight;
                let endImgDrawWidth = imgDrawSize; 
                let endImgDrawHeight = imgDrawSize / endImgAspectRatio;
                if (endImgDrawHeight > imgDrawSize) { endImgDrawHeight = imgDrawSize; endImgDrawWidth = imgDrawSize * endImgAspectRatio; } 
                mazeCtx.drawImage(goalImgToDraw, endMazePos.x * mazeCellSize + (mazeCellSize - endImgDrawWidth) / 2, endMazePos.y * mazeCellSize + (mazeCellSize - endImgDrawHeight) / 2, endImgDrawWidth, endImgDrawHeight);
            } else { 
                mazeCtx.fillStyle = 'rgba(22, 163, 74, 0.8)'; 
                mazeCtx.fillRect(endMazePos.x * mazeCellSize + imgPadding, endMazePos.y * mazeCellSize + imgPadding, imgDrawSize, imgDrawSize);
            }
        }
        
        function movePlayerMaze(direction) {
            if (!mazeGameActive || !mazeGrid.length || !mazeGrid[playerMazePos.y] || !mazeGrid[playerMazePos.y][playerMazePos.x]) return;
            let currentCell = mazeGrid[playerMazePos.y][playerMazePos.x];
            let newX = playerMazePos.x, newY = playerMazePos.y, moved = false;
            
            switch (direction) {
                case 'up': if (!currentCell.walls.top && playerMazePos.y > 0) { newY--; currentPlayerMazeImg = playerMazeImgUp; moved = true; } break;
                case 'down': if (!currentCell.walls.bottom && playerMazePos.y < mazeRows - 1) { newY++; currentPlayerMazeImg = playerMazeImgDown; moved = true; } break;
                case 'left': if (!currentCell.walls.left && playerMazePos.x > 0) { newX--; currentPlayerMazeImg = playerMazeImgLeft; moved = true; } break;
                case 'right': if (!currentCell.walls.right && playerMazePos.x < mazeCols - 1) { newX++; currentPlayerMazeImg = playerMazeImgRight; moved = true; } break;
            }
            if (moved) { 
                playerMazePos.x = newX; playerMazePos.y = newY; 
                drawMaze(); 
                checkMazeWinCondition(); 
            }
        }
        
        function checkMazeWinCondition() {
            if (playerMazePos.x === endMazePos.x && playerMazePos.y === endMazePos.y) {
                mazeGameActive = false; 
                clearInterval(mazeTimerInterval); 
                if(mazeBackgroundMusic) { mazeBackgroundMusic.pause(); mazeBackgroundMusic.currentTime = 0; }
                if (isMazeMusicOn && mazeWinMusic) mazeWinMusic.play().catch(e => console.warn("Error playing maze win music:", e));
                mazeGameWonOnce = true; 
                showMessage('太棒了!', `你成功帮助通通走出迷宫，找到了中国结！用时 ${mazeTimeElapsed} 秒！`);
                if(startMazeBtn) { startMazeBtn.textContent = '再玩一次'; startMazeBtn.disabled = false; }
                if(mazeToProductsBtn) mazeToProductsBtn.style.display = 'inline-block'; 
            }
        }
        
        function startMazeGame() {
            if (!mazeCanvas) { console.error("Maze canvas not found!"); return; }
            mazeGameActive = true; mazeTimeElapsed = 0; 
            if(updateMazeTimerDisplay) updateMazeTimerDisplay();
            if(startMazeBtn) { startMazeBtn.textContent = '游戏中...'; startMazeBtn.disabled = true; }
            if(mazeToProductsBtn) mazeToProductsBtn.style.display = 'none'; 
            clearInterval(mazeTimerInterval); 
            mazeTimerInterval = setInterval(() => { if (mazeGameActive) { mazeTimeElapsed++; updateMazeTimerDisplay(); }}, 1000); 
            
            mazeCellSize = mazeCanvas.width / mazeCols; 
            currentPlayerMazeImg = playerMazeImgDefault; 
            playerMazePos = { x: 0, y: 0 }; 
            mazeGrid = generateMaze(mazeCols, mazeRows); 
            
            if(mazeWinMusic) { mazeWinMusic.pause(); mazeWinMusic.currentTime = 0; } 
            if (isMazeMusicOn && mazeBackgroundMusic) {
                mazeBackgroundMusic.loop = true; 
                mazeBackgroundMusic.play().catch(e => console.warn("Error playing maze background music:", e));
            } else if (mazeBackgroundMusic) { 
                mazeBackgroundMusic.pause(); mazeBackgroundMusic.currentTime = 0; 
            }
            drawMaze(); 
            updateBackButtonVisibility(); 
        }
        
        document.addEventListener('keydown', (e) => {
            if (currentSection === 'section-maze' && mazeGameActive) {
                let direction = null;
                if (e.key === 'ArrowUp') direction = 'up'; 
                else if (e.key === 'ArrowDown') direction = 'down';
                else if (e.key === 'ArrowLeft') direction = 'left'; 
                else if (e.key === 'ArrowRight') direction = 'right';
                if (direction) { e.preventDefault(); movePlayerMaze(direction); }
            }
        });
        
        document.querySelectorAll('.maze-arrow-button').forEach(button => {
            const direction = button.dataset.direction; if (!direction) return;
            const pressHandler = () => { if (currentSection === 'section-maze' && mazeGameActive) movePlayerMaze(direction); button.classList.add('pressed'); };
            const releaseHandler = () => { button.classList.remove('pressed'); };
            button.addEventListener('mousedown', pressHandler); 
            button.addEventListener('mouseup', releaseHandler);
            button.addEventListener('mouseleave', () => button.classList.remove('pressed')); 
            button.addEventListener('touchstart', (e) => { e.preventDefault(); pressHandler(); }, { passive: false });
            button.addEventListener('touchend', (e) => { e.preventDefault(); releaseHandler(); });
        });

        // --- Match-3 Game Logic (消消乐) ---
        function initMatchGame() {
            const gameContext = window.matchGameContext; 

            gameContext.size = 8; 
            gameContext.gameDuration = 60; 
            gameContext.initialHintCount = 2; 
            gameContext.R_AUTO_MATCH = 0.15; 
            gameContext.R_SETUP_MOVE = 0.25; 
            gameContext.images = [
                '消消乐/保温杯.jpg', '消消乐/充电线.jpg',
                '消消乐/地球款钥匙扣.jpg', '消消乐/吉祥物毛绒玩具.jpg',
                '消消乐/金色通通手办.jpg', '消消乐/手机挂绳.jpg',
                '消消乐/四方基站徽章.jpg', '消消乐/香卡.jpg',
                '消消乐/旋转款钥匙扣.jpg'
            ];

            gameContext.board = []; 
            gameContext.selected = null; 
            gameContext.score = 0;
            gameContext.timeLeft = gameContext.gameDuration;
            gameContext.timerInterval = null; 
            gameContext.gameStarted = false; 
            gameContext.hintCount = gameContext.initialHintCount;
            gameContext.hintPair = null; 
            gameContext.isProcessingMove = false; 
            gameContext.isGamePausedForShuffle = false; 
            gameContext._xxlHintSwap = false; 
            gameContext.isFinishingSequence = false; 
            gameContext.hintUsedAndNotResolved = false; 

            const gameSection = document.getElementById('section-match-game');
            if (!gameSection) { console.error("Match game section not found!"); return; }
            gameContext.boardEl = gameSection.querySelector('#game-board');
            gameContext.scoreEl = gameSection.querySelector('#score');
            gameContext.timerEl = gameSection.querySelector('#timer');
            gameContext.actionBtn = gameSection.querySelector('#action-btn'); 
            gameContext.hintBtn = gameSection.querySelector('#hint-btn');
            gameContext.hintCountEl = gameSection.querySelector('#hint-count-display');
            gameContext.messageBoxOverlay = gameSection.querySelector('#message-box-overlay'); 
            gameContext.messageBoxText = gameSection.querySelector('#message-box-text');
            gameContext.messageBoxOk = gameSection.querySelector('#message-box-ok');
            gameContext.matchGameToProductsBtn = gameSection.querySelector('#match-game-to-products-btn'); 
            gameContext.matchGameMusicToggleBtn = gameSection.querySelector('#match-game-music-toggle');
            gameContext.matchGameMusicIcon = gameContext.matchGameMusicToggleBtn ? gameContext.matchGameMusicToggleBtn.querySelector('img') : null;

            gameContext.matchSound = null; 
            gameContext.errorSoundTone = null; 
            gameContext.clickSoundTone = null; 
            gameContext.soundsInitialized = false; 

            try { 
                gameContext.matchSound = new Audio('xiaochu.mp3'); 
            } catch (e) {
                console.warn("Error initializing matchSound Audio object. Match sound might not play.", e);
                gameContext.matchSound = { play: () => {}, currentTime: 0 }; 
            }

            gameContext.initializeToneSounds = function() {
                if (gameContext.soundsInitialized || typeof Tone === 'undefined') return;
                try {
                    gameContext.errorSoundTone = new Tone.Synth({ 
                        oscillator: { type: "square" }, 
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } 
                    }).toDestination();
                    gameContext.clickSoundTone = new Tone.MembraneSynth({ 
                        octaves: 4, pitchDecay: 0.1, 
                        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } 
                    }).toDestination();
                    gameContext.soundsInitialized = true; 
                } catch (e) { console.warn("Error initializing Tone.js sounds for match game.", e); }
            };
            gameContext.playMatchSound = function() {
                if (gameContext.isMatchGameMusicOn && gameContext.matchSound && typeof gameContext.matchSound.play === 'function') { 
                    gameContext.matchSound.currentTime = 0; 
                    gameContext.matchSound.play().catch(error => console.warn("Error playing match sound:", error.message));
                }
            };
            gameContext.playErrorSound = function() { 
                 if (gameContext.isMatchGameMusicOn && gameContext.soundsInitialized && gameContext.errorSoundTone) {
                    try { gameContext.errorSoundTone.triggerAttackRelease("A2", "8n", Tone.now()); } 
                    catch (e) { console.warn("Tone.js error sound playback failed:", e); }
                 }
            };
            gameContext.playClickSound = function() { 
                if (gameContext.isMatchGameMusicOn && gameContext.soundsInitialized && gameContext.clickSoundTone) {
                    try { gameContext.clickSoundTone.triggerAttackRelease("C4", "16n", Tone.now()); } 
                    catch (e) { console.warn("Tone.js click sound playback failed:", e); }
                }
            };

            gameContext.xxl_showMessage = function(text, okCallback = null) {
                if (!gameContext.messageBoxText || !gameContext.messageBoxOverlay) return;
                gameContext.messageBoxText.textContent = text;
                gameContext.currentMessageOkCallback = okCallback; 
                gameContext.messageBoxOverlay.classList.add('visible');
                updateBackButtonVisibility(); 
            };
            if (gameContext.messageBoxOk) {
                gameContext.messageBoxOk.onclick = () => {
                    if (gameContext.currentMessageOkCallback) { gameContext.currentMessageOkCallback(); gameContext.currentMessageOkCallback = null; }
                    if (gameContext.messageBoxOverlay) gameContext.messageBoxOverlay.classList.remove('visible');
                    updateBackButtonVisibility();
                };            
            }
            gameContext.setupBoardSize = function() {
                if (!gameContext.boardEl) return;
                gameContext.boardEl.style.gap = "6px"; 
                const parentElement = gameContext.boardEl.parentElement;
                let availableWidth = (parentElement && parentElement.clientWidth > 0) 
                    ? Math.min(parentElement.clientWidth * 0.95, 500) 
                    : Math.min(window.innerWidth * 0.90, 500); 
                const availableHeight = window.innerHeight * 0.6; 
                const boardSize = Math.min(availableWidth, availableHeight); 

                gameContext.boardEl.style.gridTemplateColumns = `repeat(${gameContext.size}, 1fr)`;
                gameContext.boardEl.style.gridTemplateRows = `repeat(${gameContext.size}, 1fr)`;
                gameContext.boardEl.style.width = `${boardSize}px`;
                gameContext.boardEl.style.height = `${boardSize}px`;
                gameContext.boardEl.style.maxWidth = "500px"; 
            };
            gameContext.boundSetupBoardSize = gameContext.setupBoardSize.bind(gameContext); 
            window.addEventListener('resize', gameContext.boundSetupBoardSize); 
            gameContext.removeResizeListener = () => window.removeEventListener('resize', gameContext.boundSetupBoardSize);

            gameContext.randomImage = function() { return Math.floor(Math.random() * gameContext.images.length); };
            
            gameContext.createBoard = function() {
                gameContext.board = [];
                for (let r = 0; r < gameContext.size; r++) {
                    let row = [];
                    for (let c = 0; c < gameContext.size; c++) {
                        row.push(gameContext.randomImage()); 
                    }
                    gameContext.board.push(row);
                }
                let initialClearSafety = 0; const MAX_INITIAL_CLEAR_LOOPS = 10; 
                while (initialClearSafety < MAX_INITIAL_CLEAR_LOOPS) {
                    initialClearSafety++;
                    let matches = gameContext.findMatchesOnBoard(gameContext.board);
                    if (matches.length === 0) { 
                        if (gameContext.findHintPairOnBoard(gameContext.board)) break; 
                        else { 
                            gameContext.shuffleBoard(); 
                            if (gameContext.findMatchesOnBoard(gameContext.board).length > 0 || !gameContext.findHintPairOnBoard(gameContext.board)) {
                                for (let r_fill = 0; r_fill < gameContext.size; r_fill++) { for (let c_fill = 0; c_fill < gameContext.size; c_fill++) { gameContext.board[r_fill][c_fill] = gameContext.randomImage();}}
                            } else { break; } 
                        }
                    }
                    let removed = Array.from({length: gameContext.size}, () => Array(gameContext.size).fill(false));
                    for (const m of matches) { 
                        for (let i = 0; i < m.len; i++) { 
                            let r_match = m.dir === 'h' ? m.r : m.r + i; 
                            let c_match = m.dir === 'h' ? m.c + i : m.c; 
                            if (!removed[r_match][c_match]) removed[r_match][c_match] = true; 
                        }
                    }
                    for (let r_rem = 0; r_rem < gameContext.size; r_rem++) { for (let c_rem = 0; c_rem < gameContext.size; c_rem++) { if (removed[r_rem][c_rem]) gameContext.board[r_rem][c_rem] = null; } }
                    for (let c_fall = 0; c_fall < gameContext.size; c_fall++) { 
                        let emptySlots = 0; 
                        for (let r_fall = gameContext.size - 1; r_fall >= 0; r_fall--) { 
                            if (gameContext.board[r_fall][c_fall] === null) { emptySlots++; } 
                            else if (emptySlots > 0) { 
                                gameContext.board[r_fall + emptySlots][c_fall] = gameContext.board[r_fall][c_fall]; 
                                gameContext.board[r_fall][c_fall] = null; 
                            } 
                        } 
                    }
                    for (let c_fill = 0; c_fill < gameContext.size; c_fill++) { for (let r_fill = 0; r_fill < gameContext.size; r_fill++) { if (gameContext.board[r_fill][c_fill] === null) { gameContext.board[r_fill][c_fill] = gameContext.randomImage(); }}}
                }
            };
                       
            gameContext.renderBoard = function(removedMap = null, fallMap = null) {
                if (!gameContext.boardEl || !gameContext.board) return; 
                gameContext.boardEl.innerHTML = ''; 
                let hintSwapActive = gameContext.hintPair && gameContext._xxlHintSwap; 

                for (let r = 0; r < gameContext.size; r++) { for (let c = 0; c < gameContext.size; c++) {
                    const cell = document.createElement('div'); 
                    cell.className = 'cell'; 
                    cell.dataset.row = r; cell.dataset.col = c;

                    if (gameContext.selected && gameContext.selected[0] === r && gameContext.selected[1] === c) cell.classList.add('selected');
                    if (removedMap && removedMap[r][c]) cell.classList.add('disappear'); 
                    if (fallMap && fallMap[r][c]) cell.classList.add('fall'); 
                    
                    if (gameContext.hintPair && ((gameContext.hintPair[0][0] === r && gameContext.hintPair[0][1] === c) || (gameContext.hintPair[1][0] === r && gameContext.hintPair[1][1] === c))) {
                        cell.classList.add('hint');
                        if (hintSwapActive) { 
                            cell.classList.add('hint-animate');                            
                            const targetCell = (gameContext.hintPair[0][0] === r && gameContext.hintPair[0][1] === c) ? gameContext.hintPair[1] : gameContext.hintPair[0];
                            const dx = (targetCell[1] - c); 
                            const dy = (targetCell[0] - r); 
                            cell.style.setProperty('--xxl-hint-x', `${dx * 120}%`); 
                            cell.style.setProperty('--xxl-hint-y', `${dy * 120}%`);
                        } else { 
                            cell.style.removeProperty('--xxl-hint-x'); cell.style.removeProperty('--xxl-hint-y');
                        }
                    }
                    
                    if (gameContext.board[r] && gameContext.board[r][c] !== null && gameContext.board[r][c] < gameContext.images.length) { 
                        const img = document.createElement('img'); 
                        img.src = gameContext.images[gameContext.board[r][c]]; 
                        img.alt = '文创产品'; 
                        img.onerror = () => { 
                            img.alt = '图片加载失败'; 
                            img.src = `https://placehold.co/50x50/CCCCCC/555555?text=${gameContext.board[r][c]}`; 
                        };
                        cell.appendChild(img);
                    }
                    cell.onclick = () => gameContext.handleCellClick(r, c); 
                    gameContext.boardEl.appendChild(cell);
                } }
            };
            gameContext.updateUI = function() {
                if(gameContext.scoreEl) gameContext.scoreEl.textContent = `分数：${gameContext.score}`;
                if(gameContext.timerEl) gameContext.timerEl.textContent = `剩余时间：${gameContext.timeLeft}秒`;
                if(gameContext.hintCountEl) gameContext.hintCountEl.textContent = `提示：${gameContext.hintCount}次`;
                
                const canInteract = gameContext.gameStarted && gameContext.timeLeft > 0 && !gameContext.isGamePausedForShuffle && !gameContext.isFinishingSequence;
                if(gameContext.actionBtn) gameContext.actionBtn.disabled = (gameContext.isProcessingMove && !gameContext.isGamePausedForShuffle) || canInteract; 
                if(gameContext.hintBtn) gameContext.hintBtn.disabled = gameContext.isProcessingMove || !canInteract || gameContext.hintCount <= 0 || gameContext.hintUsedAndNotResolved;
            };
            gameContext.setGameActive = function(active) {
                const allowPointerEvents = active && !gameContext.isProcessingMove && !gameContext.isGamePausedForShuffle && !gameContext.isFinishingSequence;
                if(gameContext.boardEl) gameContext.boardEl.style.pointerEvents = allowPointerEvents ? '' : 'none';
                gameContext.updateUI(); 
            };            
            gameContext.animateSwap = function(r1, c1, r2, c2, isBackSwap, callback) {
                gameContext.isProcessingMove = true; gameContext.setGameActive(false); 
                const idx1 = r1 * gameContext.size + c1; const idx2 = r2 * gameContext.size + c2;
                const cells = Array.from(gameContext.boardEl.children); const cell1 = cells[idx1]; const cell2 = cells[idx2];
                
                if (!cell1 || !cell2) { 
                    if (callback) callback(); 
                    gameContext.isProcessingMove = false; 
                    if (!gameContext.isFinishingSequence) { 
                        gameContext.setGameActive(gameContext.gameStarted && gameContext.timeLeft > 0 && !gameContext.isGamePausedForShuffle); 
                    }
                    return; 
                }
                const cellSize = cell1.offsetWidth;
                const cellGap = parseFloat(gameContext.boardEl.style.gap) || 6; 
                const dx = (c2 - c1) * (cellSize + cellGap); 
                const dy = (r2 - r1) * (cellSize + cellGap);
                const animationTime = isBackSwap ? 130 : 250; 
                
                if (!isBackSwap) { 
                    cell1.classList.add('swap'); cell2.classList.add('swap'); 
                    cell1.style.transform = `translate(${dx}px, ${dy}px)`; 
                    cell2.style.transform = `translate(${-dx}px, ${-dy}px)`; 
                } else { 
                    cell1.classList.add('swap-back-half'); cell2.classList.add('swap-back-half'); 
                    cell1.style.transform = `translate(${dx / 2}px, ${dy / 2}px)`; 
                    cell2.style.transform = `translate(${-dx / 2}px, ${-dy / 2}px)`; 
                }
                setTimeout(() => {
                    if (!isBackSwap) { 
                        cell1.classList.remove('swap'); cell2.classList.remove('swap'); 
                        cell1.style.transform = ''; cell2.style.transform = ''; 
                        if (callback) callback(); 
                    } else { 
                        cell1.classList.remove('swap-back-half'); cell2.classList.remove('swap-back-half'); 
                        cell1.classList.add('swap-back'); cell2.classList.add('swap-back'); 
                        cell1.style.transform = ''; cell2.style.transform = ''; 
                        setTimeout(() => { 
                            cell1.classList.remove('swap-back'); cell2.classList.remove('swap-back'); 
                            if (callback) callback(); 
                            gameContext.isProcessingMove = false; 
                            if (!gameContext.isFinishingSequence) { 
                                gameContext.setGameActive(gameContext.gameStarted && gameContext.timeLeft > 0 && !gameContext.isGamePausedForShuffle); 
                            }
                        }, animationTime);
                    }
                }, animationTime);
            };
            gameContext.handleCellClick = function(r, c) {
                if (gameContext.isFinishingSequence) return; 
                if (gameContext.isProcessingMove || !gameContext.gameStarted || gameContext.timeLeft <= 0 || gameContext.isGamePausedForShuffle) return; 
                
                gameContext.playClickSound(); 
                if (!gameContext.selected) { 
                    gameContext.selected = [r, c]; 
                    gameContext.renderBoard(); return; 
                }
                const [sr, sc] = gameContext.selected; 
                if (sr === r && sc === c) { 
                    gameContext.selected = null; 
                    gameContext.renderBoard(); return; 
                }
                if (Math.abs(sr - r) + Math.abs(sc - c) === 1) { 
                    gameContext.isProcessingMove = true; gameContext.setGameActive(false); 
                    gameContext.selected = null; gameContext.renderBoard(); 
                    setTimeout(() => { gameContext.animateSwap(sr, sc, r, c, false, () => {
                        gameContext.swap(sr, sc, r, c); 
                        if (gameContext.findMatchesOnBoard(gameContext.board).length > 0) { 
                            gameContext.resetHint(); 
                            gameContext.hintUsedAndNotResolved = false; 
                            setTimeout(gameContext.processMatches, 50); 
                        } else { 
                            gameContext.swap(sr, sc, r, c); 
                            gameContext.playErrorSound(); 
                            gameContext.animateSwap(sr, sc, r, c, true, () => { gameContext.renderBoard(); }); 
                        }
                    }); }, 10); 
                } else { 
                    gameContext.selected = [r, c]; 
                    gameContext.renderBoard(); 
                }
            };
            gameContext.swap = function(r1, c1, r2, c2) {
                const temp = gameContext.board[r1][c1]; 
                gameContext.board[r1][c1] = gameContext.board[r2][c2]; 
                gameContext.board[r2][c2] = temp;
            };
            gameContext.checkMatchAt = function(r_check, c_check, targetBoard) {
                if (r_check < 0 || r_check >= gameContext.size || c_check < 0 || c_check >= gameContext.size) return false;
                const val = targetBoard[r_check][c_check]; if (val === null) return false; 
                
                let h_count = 1;
                for (let i = c_check - 1; i >= 0 && targetBoard[r_check][i] === val; i--) h_count++; 
                for (let i = c_check + 1; i < gameContext.size && targetBoard[r_check][i] === val; i++) h_count++; 
                if (h_count >= 3) return true;
                
                let v_count = 1;
                for (let i = r_check - 1; i >= 0 && targetBoard[i][c_check] === val; i--) v_count++; 
                for (let i = r_check + 1; i < gameContext.size && targetBoard[i][c_check] === val; i++) v_count++; 
                if (v_count >= 3) return true; 
                
                return false;
            };
            gameContext.findMatchesOnBoard = function(currentBoard) {
                let matches = [];
                for (let r = 0; r < gameContext.size; r++) { 
                    for (let c = 0; c < gameContext.size - 2; c++) { 
                        if (currentBoard[r][c] !== null && currentBoard[r][c] === currentBoard[r][c+1] && currentBoard[r][c] === currentBoard[r][c+2]) { 
                            let len = 3; 
                            while (c + len < gameContext.size && currentBoard[r][c] === currentBoard[r][c+len]) { len++; } 
                            matches.push({r, c, len, dir: 'h'}); 
                            c += len -1; 
                        } 
                    } 
                }
                for (let c = 0; c < gameContext.size; c++) { 
                    for (let r = 0; r < gameContext.size - 2; r++) { 
                        if (currentBoard[r][c] !== null && currentBoard[r][c] === currentBoard[r+1][c] && currentBoard[r][c] === currentBoard[r+2][c]) { 
                            let len = 3; 
                            while (r + len < gameContext.size && currentBoard[r][c] === currentBoard[r+len][c]) { len++; } 
                            matches.push({r, c, len, dir: 'v'}); 
                            r += len -1; 
                        } 
                    } 
                } return matches;
            };
            gameContext.shuffleBoard = function() {
                let flatBoard = gameContext.board.flat(); 
                let attempts = 0; const MAX_ATTEMPTS = 20; 
                while (attempts < MAX_ATTEMPTS) {
                    for (let i = flatBoard.length - 1; i > 0; i--) { 
                        const j = Math.floor(Math.random() * (i + 1)); 
                        [flatBoard[i], flatBoard[j]] = [flatBoard[j], flatBoard[i]]; 
                    }
                    let currentAttemptBoard = []; 
                    for (let i = 0; i < gameContext.size; i++) { 
                        currentAttemptBoard.push(flatBoard.slice(i * gameContext.size, (i + 1) * gameContext.size)); 
                    }
                    if (gameContext.findMatchesOnBoard(currentAttemptBoard).length === 0 && gameContext.findHintPairOnBoard(currentAttemptBoard)) { 
                        gameContext.board = currentAttemptBoard; 
                        return; 
                    } 
                    attempts++;
                } 
                gameContext.createBoard(); 
            };
            gameContext.handleShuffleConfirmation = function() {
                if (gameContext.messageBoxOverlay) gameContext.messageBoxOverlay.classList.remove('visible'); 
                updateBackButtonVisibility(); 
                gameContext.shuffleBoard(); 
                gameContext.isGamePausedForShuffle = false; gameContext.isProcessingMove = false; 
                if (!gameContext.isFinishingSequence) { 
                    gameContext.setGameActive(true); 
                    if (gameContext.gameStarted && gameContext.timeLeft > 0) { gameContext.startTimer(); } 
                }
                gameContext.renderBoard(); 
                gameContext.updateUI();
            };
            gameContext.processMatches = function() {
                gameContext.isProcessingMove = true; 
                let matches = gameContext.findMatchesOnBoard(gameContext.board);

                if (matches.length === 0) { 
                    if (gameContext.isFinishingSequence) { 
                        gameContext.finalizeGameEnd(); 
                        return; 
                    }
                    if (gameContext.gameStarted && gameContext.timeLeft > 0 && !gameContext.isGamePausedForShuffle) {
                       if (!gameContext.findHintPairOnBoard(gameContext.board)) { 
                            gameContext.isGamePausedForShuffle = true; 
                            gameContext.setGameActive(false); 
                            clearInterval(gameContext.timerInterval); 
                            gameContext.xxl_showMessage("棋盘上没有可移动的组合了！点击“好”将为您洗牌。", gameContext.handleShuffleConfirmation); 
                            return;
                        }
                    } 
                    gameContext.isProcessingMove = false; 
                    if (!gameContext.isFinishingSequence) { 
                        gameContext.setGameActive(gameContext.gameStarted && gameContext.timeLeft > 0 && !gameContext.isGamePausedForShuffle);
                    }
                    gameContext.renderBoard(); 
                    return;
                } 
                
                gameContext.resetHint(); 
                gameContext.hintUsedAndNotResolved = false; 

                let removed = Array.from({length: gameContext.size}, () => Array(gameContext.size).fill(false)); 
                let currentMatchScore = 0;
                for (const m of matches) { 
                    for (let i = 0; i < m.len; i++) { 
                        let r = m.dir === 'h' ? m.r : m.r + i; 
                        let c = m.dir === 'h' ? m.c + i : m.c; 
                        if (!removed[r][c]) { removed[r][c] = true; currentMatchScore += 10; } 
                    } 
                }
                gameContext.score += currentMatchScore; 
                if (currentMatchScore > 0) { gameContext.playMatchSound(); } 
                gameContext.updateUI(); 
                gameContext.renderBoard(removed); 
                
                setTimeout(() => {
                    for (let r = 0; r < gameContext.size; r++) { for (let c = 0; c < gameContext.size; c++) { if (removed[r][c]) { gameContext.board[r][c] = null; } } }
                    
                    let fallMap = Array.from({length: gameContext.size}, () => Array(gameContext.size).fill(false)); 
                    for (let c = 0; c < gameContext.size; c++) { 
                        let emptySlots = 0; 
                        for (let r = gameContext.size - 1; r >= 0; r--) { 
                            if (gameContext.board[r][c] === null) { emptySlots++; } 
                            else if (emptySlots > 0) { 
                                gameContext.board[r + emptySlots][c] = gameContext.board[r][c]; 
                                gameContext.board[r][c] = null; 
                                fallMap[r + emptySlots][c] = true; 
                            } 
                        } 
                    } 
                    for (let c = 0; c < gameContext.size; c++) { 
                        for (let r = 0; r < gameContext.size; r++) { 
                            if (gameContext.board[r][c] === null) {
                                let placedItem = -1; 
                                let randomChoice = Math.random();
                                if (randomChoice < gameContext.R_AUTO_MATCH) { 
                                    for (let imgIndex = 0; imgIndex < gameContext.images.length; imgIndex++) { 
                                        gameContext.board[r][c] = imgIndex; 
                                        if (gameContext.checkMatchAt(r, c, gameContext.board)) { placedItem = imgIndex; break; } 
                                    } 
                                    if (placedItem === -1) gameContext.board[r][c] = null; 
                                }
                                if (placedItem === -1 && randomChoice >= gameContext.R_AUTO_MATCH && randomChoice < gameContext.R_AUTO_MATCH + gameContext.R_SETUP_MOVE) {
                                    let tempBoardForSetup = gameContext.board.map(row => [...row]); 
                                    for (let imgIndex = 0; imgIndex < gameContext.images.length; imgIndex++) { 
                                        tempBoardForSetup[r][c] = imgIndex; 
                                        const directions = [[0,1],[1,0], [0,-1], [-1,0]]; 
                                        for (const [dr_s, dc_s] of directions) { 
                                            let nr_s = r + dr_s; let nc_s = c + dc_s; 
                                            if (nr_s >= 0 && nr_s < gameContext.size && nc_s >= 0 && nc_s < gameContext.size && tempBoardForSetup[nr_s][nc_s] !== null) {
                                                let tempVal = tempBoardForSetup[r][c]; tempBoardForSetup[r][c] = tempBoardForSetup[nr_s][nc_s]; tempBoardForSetup[nr_s][nc_s] = tempVal;
                                                if (gameContext.findMatchesOnBoard(tempBoardForSetup).length > 0) { 
                                                    placedItem = imgIndex; 
                                                    tempVal = tempBoardForSetup[r][c]; tempBoardForSetup[r][c] = tempBoardForSetup[nr_s][nc_s]; tempBoardForSetup[nr_s][nc_s] = tempVal; 
                                                    break; 
                                                }
                                                tempVal = tempBoardForSetup[r][c]; tempBoardForSetup[r][c] = tempBoardForSetup[nr_s][nc_s]; tempBoardForSetup[nr_s][nc_s] = tempVal; 
                                            } 
                                        } 
                                        if (placedItem !== -1) break; 
                                    }
                                }
                                if (placedItem !== -1) { gameContext.board[r][c] = placedItem; } 
                                else { 
                                    let attempts = 0; const maxAttempts = gameContext.images.length * 2; 
                                    while(attempts < maxAttempts) { 
                                        let imgIdx = gameContext.randomImage(); 
                                        gameContext.board[r][c] = imgIdx; 
                                        if (!gameContext.checkMatchAt(r, c, gameContext.board)) { break; } 
                                        attempts++; 
                                    } 
                                    if (attempts === maxAttempts) { gameContext.board[r][c] = gameContext.randomImage(); } 
                                } 
                                fallMap[r][c] = true; 
                            } 
                        } 
                    } 
                    gameContext.renderBoard(null, fallMap); 
                    setTimeout(gameContext.processMatches, 400); 
                }, 400); 
            };

            gameContext.startTimer = function() {
                if (gameContext.timerInterval) clearInterval(gameContext.timerInterval); 
                if(gameContext.timerEl) gameContext.timerEl.textContent = `剩余时间：${gameContext.timeLeft}秒`;
                
                gameContext.timerInterval = setInterval(() => {
                    if (gameContext.isGamePausedForShuffle || gameContext.isFinishingSequence) { 
                        if (gameContext.isFinishingSequence && gameContext.timeLeft <=0 && !gameContext.isProcessingMove) {
                            gameContext.finalizeGameEnd();
                        }
                        return;
                    }

                    gameContext.timeLeft--; 
                    gameContext.updateUI(); 

                    if (gameContext.timeLeft <= 0) { 
                        clearInterval(gameContext.timerInterval); 
                        if(gameContext.timerEl) gameContext.timerEl.textContent = '时间到！';
                        gameContext.isFinishingSequence = true; 
                        
                        if (!gameContext.isProcessingMove) {
                            gameContext.finalizeGameEnd();
                        } 
                    }
                }, 1000);
            };
            
            gameContext.finalizeGameEnd = function() {
                if (gameContext.timerInterval) clearInterval(gameContext.timerInterval); 
                
                gameContext.gameStarted = false; 
                gameContext.matchGameCompletedOnce = true; 
                window.matchGameContext.hasEverCompletedMatchGame = true; 
                
                const messageAlreadyShown = gameContext.messageBoxOverlay && gameContext.messageBoxOverlay.classList.contains('visible') && 
                                         gameContext.messageBoxText && gameContext.messageBoxText.textContent && 
                                         gameContext.messageBoxText.textContent.startsWith("时间到！你的最终分数是：");

                if (!messageAlreadyShown) {
                     gameContext.xxl_showMessage(`时间到！你的最终分数是：${gameContext.score}`);
                }
                
                gameContext.isFinishingSequence = false; 
                gameContext.isProcessingMove = false; 

                gameContext.resetHint(); 

                if(gameContext.actionBtn) {
                    gameContext.actionBtn.textContent = '再来一次'; 
                }
                if(gameContext.matchGameToProductsBtn) {
                    gameContext.matchGameToProductsBtn.style.display = 'inline-block'; 
                }
                
                gameContext.updateUI(); 
                gameContext.setGameActive(false); 
            };

            gameContext.resetHint = function() {
                if (gameContext.hintPair) { 
                    const oldHintPair = gameContext.hintPair;
                    gameContext.hintPair = null; 
                    if (gameContext.boardEl && gameContext.boardEl.children.length > 0) {
                        [oldHintPair[0], oldHintPair[1]].forEach(pos => {
                            const cellIndex = pos[0] * gameContext.size + pos[1];
                            const cellElement = gameContext.boardEl.children[cellIndex];
                            if (cellElement) {
                                cellElement.classList.remove('hint', 'hint-animate');
                                cellElement.style.removeProperty('--xxl-hint-x'); 
                                cellElement.style.removeProperty('--xxl-hint-y');
                            }
                        });
                    } else { gameContext.renderBoard(); } 
                }
                 gameContext._xxlHintSwap = false; 
            };
            gameContext.findHintPairOnBoard = function(currentBoard) {
                for (let r = 0; r < gameContext.size; r++) { for (let c = 0; c < gameContext.size; c++) {
                    if (c < gameContext.size - 1) { 
                        let temp = currentBoard[r][c]; currentBoard[r][c] = currentBoard[r][c+1]; currentBoard[r][c+1] = temp; 
                        if (gameContext.findMatchesOnBoard(currentBoard).length > 0) { 
                            temp = currentBoard[r][c]; currentBoard[r][c] = currentBoard[r][c+1]; currentBoard[r][c+1] = temp; 
                            return [[r,c],[r,c+1]]; 
                        } 
                        temp = currentBoard[r][c]; currentBoard[r][c] = currentBoard[r][c+1]; currentBoard[r][c+1] = temp; 
                    }
                    if (r < gameContext.size - 1) { 
                        let temp = currentBoard[r][c]; currentBoard[r][c] = currentBoard[r+1][c]; currentBoard[r+1][c] = temp; 
                        if (gameContext.findMatchesOnBoard(currentBoard).length > 0) { 
                            temp = currentBoard[r][c]; currentBoard[r][c] = currentBoard[r+1][c]; currentBoard[r+1][c] = temp; 
                            return [[r,c],[r+1,c]]; 
                        } 
                        temp = currentBoard[r][c]; currentBoard[r][c] = currentBoard[r+1][c]; currentBoard[r+1][c] = temp; 
                    }
                } } return null; 
            };
            gameContext.handleHint = function() {
                if (gameContext.isFinishingSequence || gameContext.hintCount <= 0 || !gameContext.gameStarted || gameContext.timeLeft <= 0 || gameContext.isProcessingMove || gameContext.isGamePausedForShuffle || gameContext.hintUsedAndNotResolved) return;
                
                let tempBoard = gameContext.board.map(row => [...row]); 
                gameContext.hintPair = gameContext.findHintPairOnBoard(tempBoard); 
                
                if (gameContext.hintPair) { 
                    gameContext.hintCount--; 
                    gameContext.hintUsedAndNotResolved = true; 
                    gameContext.updateUI(); 
                    gameContext._xxlHintSwap = true; 
                    gameContext.renderBoard(); 
                    setTimeout(() => { 
                        gameContext._xxlHintSwap = false; 
                        gameContext.renderBoard(); 
                    }, 1200); 
                } else { 
                    gameContext.xxl_showMessage('当前没有可消除的组合！'); 
                }
            };
            
            gameContext.startGame = async function() {
                if (!gameContext.soundsInitialized && typeof Tone !== 'undefined') { 
                    try { await Tone.start(); gameContext.initializeToneSounds(); } 
                    catch (e) { console.error("Failed to start Tone.js for match game:", e); gameContext.initializeToneSounds();  } 
                } else if (!gameContext.soundsInitialized) { 
                    gameContext.initializeToneSounds(); 
                }
                
                gameContext.score = 0; 
                gameContext.timeLeft = gameContext.gameDuration; 
                gameContext.hintCount = gameContext.initialHintCount;
                gameContext.selected = null; 
                gameContext.isProcessingMove = false; 
                gameContext.isGamePausedForShuffle = false;
                gameContext.matchGameCompletedOnce = false; 
                gameContext.isFinishingSequence = false; 
                gameContext.hintUsedAndNotResolved = false; 

                if (gameContext.timerInterval) clearInterval(gameContext.timerInterval); 
                if(gameContext.messageBoxOverlay) gameContext.messageBoxOverlay.classList.remove('visible'); 
                updateBackButtonVisibility(); 
                
                gameContext.createBoard(); 
                
                gameContext.renderBoard(); 
                
                gameContext.gameStarted = true; 
                gameContext.setGameActive(true); 
                gameContext.startTimer(); 
                gameContext.updateUI(); 
                if(gameContext.actionBtn) gameContext.actionBtn.textContent = '游戏中...'; 
            };


            gameContext.prepareForView = function() {
                gameContext.setupBoardSize(); 
                gameContext.resetHint();      

                if (window.matchGameContext.hasEverCompletedMatchGame) { 
                    if(gameContext.actionBtn) {
                        gameContext.actionBtn.textContent = '再来一次'; 
                    }
                    if(gameContext.matchGameToProductsBtn) {
                        gameContext.matchGameToProductsBtn.style.display = 'inline-block'; 
                    }
                    if (!gameContext.gameStarted && !gameContext.isFinishingSequence) {
                        gameContext.timeLeft = gameContext.gameDuration;
                        gameContext.score = 0;
                        gameContext.hintCount = gameContext.initialHintCount;
                        if (!gameContext.board || gameContext.board.length === 0) { 
                           gameContext.createBoard(); 
                        }
                    }
                } else { 
                    gameContext.timeLeft = gameContext.gameDuration;
                    gameContext.score = 0;
                    gameContext.hintCount = gameContext.initialHintCount;
                    if(gameContext.actionBtn) {
                         gameContext.actionBtn.textContent = '开始游戏';
                    }
                    if(gameContext.matchGameToProductsBtn) {
                        gameContext.matchGameToProductsBtn.style.display = 'none'; 
                    }
                    if (!gameContext.gameStarted && !gameContext.isFinishingSequence) {
                         if (!gameContext.board || gameContext.board.length === 0) { 
                            gameContext.createBoard(); 
                        }
                    }
                }
                gameContext.isFinishingSequence = false; 
                gameContext.isProcessingMove = false; 
                gameContext.hintUsedAndNotResolved = false; 

                if(gameContext.timerEl) gameContext.timerEl.textContent = `剩余时间：${gameContext.timeLeft}秒`;
                
                if (gameContext.matchGameMusicIcon) {
                    const iconSrc = gameContext.isMatchGameMusicOn ? 'music_on.png' : 'music_off.png';
                    gameContext.matchGameMusicIcon.src = iconSrc;
                    gameContext.matchGameMusicIcon.alt = gameContext.isMatchGameMusicOn ? 'Music On' : 'Music Off';
                    gameContext.matchGameMusicIcon.onerror = () => { 
                        gameContext.matchGameMusicIcon.parentElement.innerHTML = `<span style="font-size:12px;">🎵${gameContext.isMatchGameMusicOn ? 'On':'Off'}</span>`;
                     };
                }

                gameContext.renderBoard(); 
                gameContext.updateUI(); 
                gameContext.setGameActive(gameContext.gameStarted && !gameContext.isFinishingSequence); 
            };


            if(gameContext.matchGameMusicToggleBtn && gameContext.matchGameMusicIcon) {
                gameContext.matchGameMusicToggleBtn.onclick = () => {
                    gameContext.isMatchGameMusicOn = !gameContext.isMatchGameMusicOn;
                    const newIconSrc = gameContext.isMatchGameMusicOn ? 'music_on.png' : 'music_off.png';
                    gameContext.matchGameMusicIcon.src = newIconSrc;
                    gameContext.matchGameMusicIcon.alt = gameContext.isMatchGameMusicOn ? 'Music On' : 'Music Off';
                    gameContext.matchGameMusicIcon.onerror = () => {
                        gameContext.matchGameMusicIcon.parentElement.innerHTML = `<span style="font-size:12px;">🎵${gameContext.isMatchGameMusicOn ? 'On':'Off'}</span>`;
                    };
                };
            }
            
            gameContext.setupBoardSize(); 
            if (!gameContext.board || gameContext.board.length === 0) { 
                 gameContext.createBoard(); 
            }
            gameContext.prepareForView(); 

            if(gameContext.actionBtn) {
                gameContext.actionBtn.onclick = function() { 
                    if ((gameContext.isProcessingMove && !gameContext.isGamePausedForShuffle) || gameContext.isFinishingSequence) return; 
                    gameContext.startGame(); 
                };
            }
            if(gameContext.hintBtn) { 
                gameContext.hintBtn.onclick = gameContext.handleHint; 
            }
            if(gameContext.matchGameToProductsBtn) {
                gameContext.matchGameToProductsBtn.onclick = () => navigateTo('section-products');
            }
        } 


        // --- DOMContentLoaded: Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            const welcomeSection = document.getElementById('section-welcome');
            if (welcomeSection) welcomeSection.classList.add('active-section'); 
            else console.error("Welcome section not found on DOMContentLoaded");
            updateBackButtonVisibility(); 

            document.querySelectorAll('.product-item').forEach(item => {
                const staticDescEl = item.querySelector('p.static-description');
                if (staticDescEl && item.dataset.description) {
                    staticDescEl.innerHTML = item.dataset.description.replace(/\n/g, '<br>');
                }
            });

            if (clickGameMusicIcon) {
                const initialClickIconSrc = isClickGameMusicOn ? 'music_on.png' : 'music_off.png';
                clickGameMusicIcon.src = initialClickIconSrc; clickGameMusicIcon.alt = isClickGameMusicOn ? 'Music On' : 'Music Off';
                clickGameMusicIcon.onerror = () => {
                    clickGameMusicIcon.parentElement.innerHTML = `<span style="font-size:12px;">🎵${isClickGameMusicOn ? 'On':'Off'}</span>`;
                };
            }
            if (mazeGameMusicIcon) {
                const initialMazeIconSrc = isMazeMusicOn ? 'music_on.png' : 'music_off.png';
                mazeGameMusicIcon.src = initialMazeIconSrc; mazeGameMusicIcon.alt = isMazeMusicOn ? 'Music On' : 'Music Off';
                mazeGameMusicIcon.onerror = () => {
                    mazeGameMusicIcon.parentElement.innerHTML = `<span style="font-size:12px;">🎵${isMazeMusicOn ? 'On':'Off'}</span>`;
                };
            }
        });

        // --- Global Click Listener (MODIFIED FOR STRICTER MODALS) ---
        window.onclick = function(event) {
            // This function is intentionally left mostly empty to prevent modals
            // from closing when clicking on their overlays/backgrounds.
            // Modals should only be closed via their explicit close buttons.
        }
    </script>
</body>
</html>
